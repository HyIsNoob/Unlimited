
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gojo Satoru - Unlimited</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        
        /* Container ensures canvas is on top */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* Video Element: Kept for MediaPipe logic, but hidden visually */
        #input_video { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 1px; 
            height: 1px; 
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }
        
        /* Landing Page Overlay */
        #landing-page {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); /* Semi-transparent to see particles */
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s ease-out;
        }
        .landing-content {
            max-width: 900px;
            padding: 30px;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #333;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
            border-radius: 4px;
        }
        #landing-page h1 { color: #0ff; text-shadow: 0 0 15px #0ff; margin: 0 0 10px 0; font-size: 2.5rem; letter-spacing: 4px; }
        #landing-page .subtitle { color: #888; margin-bottom: 40px; font-size: 1rem; letter-spacing: 2px; text-transform: uppercase; }
        
        .tutorial-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 40px;
            text-align: left;
        }
        @media (max-width: 768px) {
            .tutorial-grid { grid-template-columns: 1fr; }
            #landing-page h1 { font-size: 1.8rem; }
        }
        .tutorial-card {
            border: 1px solid #333;
            padding: 20px;
            background: rgba(0,0,0,0.6);
            transition: transform 0.2s;
        }
        .tutorial-card:hover { border-color: #555; transform: translateY(-2px); }
        .tutorial-card h3 { color: #d0f; font-size: 1.1rem; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 10px; }
        .tutorial-card p { font-size: 0.9rem; color: #ccc; line-height: 1.5; margin: 0; }
        .key-highlight { color: #fff; font-weight: bold; }

        .info-note { margin-bottom: 30px; color: #0ff; font-size: 0.9rem; border-top: 1px solid #333; padding-top: 20px; width: 100%; }

        #start-btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: 0.3s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            font-weight: bold;
        }
        #start-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
        }
        .credits-small { margin-top: 20px; font-size: 0.8rem; color: #444; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
            display: none; /* Hidden until start */
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .warning { color: #f00; text-shadow: 0 0 5px #f00; border-color: #f00; }
        
        /* Flash Effect Overlay */
        #flash-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 99;
            transition: opacity 0.1s ease-out;
        }

        /* Credits & Controls */
        #credit {
            position: absolute;
            top: 10px;
            right: 15px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 10px;
            z-index: 20;
            pointer-events: none;
            letter-spacing: 1px;
            display: none; /* Hidden until start */
        }

        #controls {
            position: absolute;
            top: 30px;
            right: 15px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            display: none; /* Hidden until start */
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #444;
            color: #888;
            padding: 6px 12px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            transition: all 0.3s;
            pointer-events: auto;
            text-transform: uppercase;
            width: 110px;
            text-align: center;
        }
        
        .control-btn.active {
            border-color: #0ff;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            background: rgba(0, 50, 50, 0.6);
        }

        .control-btn:hover {
            background: rgba(30, 30, 30, 0.8);
        }

        /* Canvas orientation */
        canvas { 
            display: block; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 10;
        }
    </style>

    <!-- 1. Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- 2. Post Processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- 3. MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Video Element for MediaPipe (Hidden visually, used for logic) -->
    <video id="input_video" playsinline></video>
    
    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Landing Page -->
    <div id="landing-page">
        <div class="landing-content">
            <h1>DOMAIN EXPANSION: AR</h1>
            <p class="subtitle">Gojo Satoru Cursed Technique Simulation</p>
            
            <div class="tutorial-grid">
                <div class="tutorial-card">
                    <h3>1. RED & BLUE</h3>
                    <p>Show your hands to activate techniques.<br>
                    <span class="key-highlight">Right Hand</span> = Reversal Red<br>
                    <span class="key-highlight">Left Hand</span> = Lapse Blue</p>
                </div>
                <div class="tutorial-card">
                    <h3>2. HOLLOW PURPLE</h3>
                    <p>Bring your <span class="key-highlight">palms close together</span> to merge the red and blue energies into the imaginary mass.</p>
                </div>
                <div class="tutorial-card">
                    <h3>3. SNAP TO FIRE</h3>
                    <p>While holding Purple, <span class="key-highlight">PINCH</span> (Thumb + Middle) and <span class="key-highlight">RELEASE</span> quickly to launch the attack.</p>
                </div>
            </div>

            <div class="info-note">
                <p>Virtual Hand Interface System</p>
            </div>

            <button id="start-btn" onclick="startGame()">ENTER VOID</button>
            <div class="credits-small">Created by HyIsNoob</div>
        </div>
    </div>

    <!-- UI Logs -->
    <div id="ui-layer">
        <div class="stat-box" id="log-left">LEFT: Searching...</div>
        <div class="stat-box" id="log-right">RIGHT: Searching...</div>
        <div class="stat-box" id="log-system">SYSTEM: Idle</div>
    </div>

    <!-- Credits & Controls -->
    <div id="credit">HyIsNoob</div>
    <div id="controls">
        <button id="btn-mute" class="control-btn" onclick="toggleMute()">Audio: ON</button>
        <button id="btn-log" class="control-btn active" onclick="toggleLogs()">Logs: ON</button>
        <button id="btn-hands" class="control-btn active" onclick="toggleHands()">Hands: ON</button>
    </div>

    <!-- Screen Flash -->
    <div id="flash-overlay"></div>

    <!-- Main Logic -->
    <script>
        // --- CONSTANTS ---
        const PALM_IDX = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_TIP = 12;
        const RING_TIP = 16;
        const PINKY_TIP = 20;

        const STATE = {
            IDLE: 'IDLE',
            SINGLE: 'SINGLE', // Red/Blue separate
            MERGING: 'MERGING', // Hands close, forming purple
            HOLDING: 'HOLDING', // Purple formed, waiting for snap
            EXPLODING: 'EXPLODING', // Boom
            COOLDOWN: 'COOLDOWN'
        };

        // Configuration
        const CONFIG = {
            particleCount: 6000, // Optimized count for smoother performance
            mergeDistance: 0.20,
            breakDistance: 0.40,
            hollowRadius: 0.4, 
            snapThreshold: 0.08, 
            bloomStrength: 3.5, 
            bloomRadius: 0.6,
            bloomThreshold: 0.1, 
        };

        // Global Variables
        let camera, scene, renderer, composer, bloomPass;
        let particleSystem;
        let handVisualizer; 
        let currentState = STATE.IDLE;
        let lastState = STATE.IDLE; 
        let snapPrimed = false; 
        let lastSnapPrimed = false;
        let appTime = 0;
        let cooldownTimer = 0;
        let gameStarted = false; 
        let camInstance = null; 
        let isMuted = false;
        let isHandsVisible = true;
        let lastResults = null;
        
        // Shake Effect
        let shakeIntensity = 0;
        
        // Hand Data Container
        const handsData = {
            left: { present: false, x: 0, y: 0, gesture: 'OPEN', lastGesture: 'NONE', pinchDist: 1 },
            right: { present: false, x: 0, y: 0, gesture: 'OPEN', lastGesture: 'NONE', pinchDist: 1 },
            distance: 1, 
            center: new THREE.Vector3() 
        };

        // --- SOUND MANAGER (Web Audio API) ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.loops = {
                    hold: null,
                    charge: null,
                    red: null,
                    blue: null
                };
                
                // Track active SFX states to avoid spamming start calls
                this.activeStates = {
                    red: 'NONE',  // 'OPEN', 'FIST', 'NONE'
                    blue: 'NONE'
                };
            }

            init() {
                if (this.initialized) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.4;
                this.masterGain.connect(this.ctx.destination);
                this.initialized = true;
                
                // Warm up
                this.ctx.resume();
            }
            
            toggleMute() {
                if (!this.initialized) return;
                isMuted = !isMuted;
                const targetGain = isMuted ? 0 : 0.4;
                // Smooth transition
                const t = this.ctx.currentTime;
                this.masterGain.gain.cancelScheduledValues(t);
                this.masterGain.gain.linearRampToValueAtTime(targetGain, t + 0.1);
                
                const btn = document.getElementById('btn-mute');
                if (isMuted) {
                    btn.innerText = "Audio: OFF";
                    btn.classList.remove('active');
                } else {
                    btn.innerText = "Audio: ON";
                    btn.classList.add('active');
                }
            }

            // --- RED TECHNIQUE (Repulsion - High Pitch, Unstable) ---
            playRedOpen() {
                if (this.activeStates.red === 'OPEN') return;
                this.stopRed();
                this.activeStates.red = 'OPEN';
                
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                // High unstable whine
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, t);
                
                // Tremolo (Amplitude modulation)
                const lfo = this.ctx.createOscillator();
                lfo.frequency.value = 15; // Fast stutter
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 500;
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.15, t + 0.2);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 800;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                this.loops.red = { nodes: [osc, gain, filter] };
            }

            playRedFist() {
                if (this.activeStates.red === 'FIST') return;
                this.stopRed(); 
                this.activeStates.red = 'FIST';
                
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                // Screeching power up
                const osc = this.ctx.createOscillator();
                osc.type = 'square';
                osc.frequency.setValueAtTime(600, t);
                osc.frequency.linearRampToValueAtTime(1200, t + 0.5); // Pitch up

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.2, t + 0.1);

                // Chaotic LFO on frequency
                const lfo = this.ctx.createOscillator();
                lfo.type = 'sawtooth';
                lfo.frequency.value = 30;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 100;

                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                lfo.start(t);
                this.loops.red = { nodes: [osc, gain, lfo, lfoGain] };
            }

            stopRed() {
                if (this.activeStates.red === 'NONE') return;
                this.activeStates.red = 'NONE';
                if (this.loops.red) {
                    const t = this.ctx.currentTime;
                    const { nodes } = this.loops.red;
                    nodes[1].gain.cancelScheduledValues(t);
                    nodes[1].gain.linearRampToValueAtTime(0, t + 0.1);
                    setTimeout(() => {
                        nodes.forEach(n => { try{ n.stop(); }catch(e){} try{ n.disconnect(); }catch(e){} });
                    }, 150);
                    this.loops.red = null;
                }
            }

            // --- BLUE TECHNIQUE (Attraction - Low Pitch, Heavy) ---
            playBlueOpen() {
                if (this.activeStates.blue === 'OPEN') return;
                this.stopBlue(); 
                this.activeStates.blue = 'OPEN';
                
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                // Deep drone
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(80, t);
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3, t + 0.5);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                this.loops.blue = { nodes: [osc, gain, filter] };
            }

            playBlueFist() {
                if (this.activeStates.blue === 'FIST') return;
                this.stopBlue(); 
                this.activeStates.blue = 'FIST';
                
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                // Intense vacuum / distortion
                const osc1 = this.ctx.createOscillator();
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(60, t);
                
                const osc2 = this.ctx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(58, t); // Beat frequency

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.35, t + 0.1);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(100, t);
                filter.frequency.linearRampToValueAtTime(50, t + 1); // Closing in

                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                osc1.start(t);
                osc2.start(t);
                this.loops.blue = { nodes: [osc1, osc2, gain, filter] };
            }

            stopBlue() {
                if (this.activeStates.blue === 'NONE') return;
                this.activeStates.blue = 'NONE';
                if (this.loops.blue) {
                    const t = this.ctx.currentTime;
                    const { nodes } = this.loops.blue;
                    const gainNode = nodes.find(n => n instanceof GainNode);
                    if(gainNode) {
                        gainNode.gain.cancelScheduledValues(t);
                        gainNode.gain.linearRampToValueAtTime(0, t + 0.1);
                    }
                    setTimeout(() => {
                        nodes.forEach(n => { try{ n.stop(); }catch(e){} try{ n.disconnect(); }catch(e){} });
                    }, 150);
                    this.loops.blue = null;
                }
            }

            // --- CORE SFX ---
            playMerge() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc1.frequency.setValueAtTime(100, t);
                osc1.frequency.exponentialRampToValueAtTime(600, t + 1.0);
                
                osc2.frequency.setValueAtTime(800, t);
                osc2.frequency.exponentialRampToValueAtTime(600, t + 1.0);

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.5, t + 0.5);
                gain.gain.linearRampToValueAtTime(0, t + 1.2);

                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(this.masterGain);

                osc1.start(t);
                osc2.start(t);
                osc1.stop(t + 1.2);
                osc2.stop(t + 1.2);
            }

            startHoldLoop() {
                if (!this.ctx || this.loops.hold) return;
                const t = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();

                // Heavy Bass Drone
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(55, t); // Low A

                // LFO for instability/throbbing
                lfo.frequency.setValueAtTime(8, t); // 8Hz flutter
                lfoGain.gain.value = 50; // Modulate frequency slightly

                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.2, t + 1);

                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                lfo.start(t);

                this.loops.hold = { nodes: [osc, gain, lfo, lfoGain] };
            }

            stopHoldLoop() {
                if (this.loops.hold) {
                    const t = this.ctx.currentTime;
                    const { nodes } = this.loops.hold;
                    // Fade out
                    nodes[1].gain.cancelScheduledValues(t);
                    nodes[1].gain.linearRampToValueAtTime(0, t + 0.2);
                    
                    setTimeout(() => {
                        nodes.forEach(n => { try{ n.stop(); }catch(e){} try{ n.disconnect(); }catch(e){} });
                    }, 250);
                    this.loops.hold = null;
                }
            }

            startChargeLoop() {
                if (!this.ctx || this.loops.charge) return;
                const t = this.ctx.currentTime;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(800, t + 3); // Rising tension

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3, t + 0.1);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                this.loops.charge = { nodes: [osc, gain] };
            }

            stopChargeLoop() {
                if (this.loops.charge) {
                    const t = this.ctx.currentTime;
                    const { nodes } = this.loops.charge;
                    nodes[1].gain.cancelScheduledValues(t);
                    nodes[1].gain.linearRampToValueAtTime(0, t + 0.1);
                    setTimeout(() => {
                        nodes.forEach(n => { try{ n.stop(); }catch(e){} try{ n.disconnect(); }catch(e){} });
                    }, 150);
                    this.loops.charge = null;
                }
            }

            playExplosion() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                // 1. Noise Burst
                const bufferSize = this.ctx.sampleRate * 2.0;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1);
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                // Filter the noise to sound like a boom, not hiss
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, t);
                filter.frequency.exponentialRampToValueAtTime(100, t + 1);

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(2.0, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 1.5);

                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                noise.start(t);

                // 2. Sub Drop (The "Impact")
                const sub = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                sub.frequency.setValueAtTime(150, t);
                sub.frequency.exponentialRampToValueAtTime(10, t + 1);
                
                subGain.gain.setValueAtTime(1.0, t);
                subGain.gain.exponentialRampToValueAtTime(0.01, t + 1);

                sub.connect(subGain);
                subGain.connect(this.masterGain);
                sub.start(t);
                sub.stop(t + 1);
            }
        }

        const sfx = new SoundManager();

        // --- UTILS: TEXTURE GENERATION ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- VIRTUAL HAND VISUALIZER ---
        class HandVisualizer {
            constructor(scene) {
                this.scene = scene;
                // Hand connections: pairs of indices
                this.connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                    [0, 5], [5, 6], [6, 7], [7, 8], // Index
                    [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                    [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                    [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                    [5, 9], [9, 13], [13, 17], [0, 17] // Palm
                ];

                this.hands = []; // Array to store mesh data for multiple hands
                
                // Create pool for 2 hands
                for (let i=0; i<2; i++) {
                    this.hands.push(this.createHandMesh());
                }
            }

            createHandMesh() {
                // Joints (Points)
                const jointGeo = new THREE.BufferGeometry();
                const jointPos = new Float32Array(21 * 3);
                jointGeo.setAttribute('position', new THREE.BufferAttribute(jointPos, 3));
                
                const jointMat = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.15,
                    map: createGlowTexture(),
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthTest: false
                });
                const joints = new THREE.Points(jointGeo, jointMat);

                // Bones (Lines)
                const boneGeo = new THREE.BufferGeometry();
                // 24 connections * 2 vertices per connection * 3 coords
                const bonePos = new Float32Array(this.connections.length * 2 * 3);
                boneGeo.setAttribute('position', new THREE.BufferAttribute(bonePos, 3));
                
                const boneMat = new THREE.LineBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    linewidth: 2
                });
                const bones = new THREE.LineSegments(boneGeo, boneMat);

                const group = new THREE.Group();
                group.add(bones);
                group.add(joints);
                group.visible = false; // Hidden by default
                this.scene.add(group);

                return { group, joints, bones, jointPos, bonePos };
            }

            update(results) {
                // Always reset visibility first
                this.hands.forEach(h => h.group.visible = false);

                // If toggle is off or no results, return
                if (!isHandsVisible || !results || !results.multiHandLandmarks) return;

                // 3D Mapping Logic (Same as particles - Optimized)
                // Note: We duplicate logic slightly to avoid object creation
                
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    if (i >= this.hands.length) break;

                    const landmarks = results.multiHandLandmarks[i];
                    const handMesh = this.hands[i];
                    handMesh.group.visible = true;

                    // Update Joints
                    const positions = handMesh.jointPos;
                    for (let j = 0; j < landmarks.length; j++) {
                        // Inlined mapTo3D
                        const x = (1.0 - landmarks[j].x - 0.5) * 8;
                        const y = -(landmarks[j].y - 0.5) * 6;
                        const z = -landmarks[j].z * 5;

                        positions[j * 3] = x;
                        positions[j * 3 + 1] = y;
                        positions[j * 3 + 2] = z;
                    }
                    handMesh.joints.geometry.attributes.position.needsUpdate = true;

                    // Update Bones
                    const bonePositions = handMesh.bonePos;
                    let bIdx = 0;
                    
                    // Access positions directly from joint array to save recalculation
                    for(let k=0; k<this.connections.length; k++) {
                        const idx1 = this.connections[k][0];
                        const idx2 = this.connections[k][1];
                        
                        bonePositions[bIdx++] = positions[idx1 * 3];
                        bonePositions[bIdx++] = positions[idx1 * 3 + 1];
                        bonePositions[bIdx++] = positions[idx1 * 3 + 2];
                        
                        bonePositions[bIdx++] = positions[idx2 * 3];
                        bonePositions[bIdx++] = positions[idx2 * 3 + 1];
                        bonePositions[bIdx++] = positions[idx2 * 3 + 2];
                    }
                    handMesh.bones.geometry.attributes.position.needsUpdate = true;
                }
            }
        }

        // --- CONTROLS LOGIC ---
        function toggleMute() {
            sfx.toggleMute();
        }

        function toggleLogs() {
            const ui = document.getElementById('ui-layer');
            const btn = document.getElementById('btn-log');
            if (ui.style.display === 'none') {
                ui.style.display = 'block';
                btn.innerText = 'LOGS: ON';
                btn.classList.add('active');
            } else {
                ui.style.display = 'none';
                btn.innerText = 'LOGS: OFF';
                btn.classList.remove('active');
            }
        }

        function toggleHands() {
            isHandsVisible = !isHandsVisible;
            const btn = document.getElementById('btn-hands');
            if (isHandsVisible) {
                btn.innerText = 'Hands: ON';
                btn.classList.add('active');
            } else {
                btn.innerText = 'Hands: OFF';
                btn.classList.remove('active');
            }
        }

        // --- START GAME LOGIC ---
        function startGame() {
            const landing = document.getElementById('landing-page');
            landing.style.opacity = '0';
            setTimeout(() => { landing.style.display = 'none'; }, 500);

            // Show UI elements
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('credit').style.display = 'block';
            document.getElementById('controls').style.display = 'flex';

            // Init Audio
            sfx.init();

            gameStarted = true;
            if (camInstance) {
                camInstance.start();
            }
        }

        // --- PARTICLE SYSTEM ENGINE ---
        class ParticleEngine {
            constructor(scene) {
                this.count = CONFIG.particleCount;
                this.geometry = new THREE.BufferGeometry();
                
                // Attributes
                const positions = new Float32Array(this.count * 3);
                const colors = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);
                
                // Custom data for physics
                this.velocities = new Float32Array(this.count * 3);
                this.angles = new Float32Array(this.count); // For spiraling
                this.radii = new Float32Array(this.count); // Distance from center
                this.randoms = new Float32Array(this.count); // Static random for deterministic role assignment

                for (let i = 0; i < this.count; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 10;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 5;
                    
                    colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                    sizes[i] = 0.5;
                    this.angles[i] = Math.random() * Math.PI * 2;
                    // Init radii spread out
                    this.radii[i] = 0.5 + Math.random() * 3.0; 
                    this.randoms[i] = Math.random();
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.PointsMaterial({
                    size: 0.2,
                    map: createGlowTexture(),
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 0.8
                });

                this.mesh = new THREE.Points(this.geometry, material);
                this.mesh.frustumCulled = false; // Always render
                scene.add(this.mesh);
            }

            update(dt) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.color.array;
                const sizes = this.geometry.attributes.size.array;
                
                // Color Definitions
                const colRed = { r: 1, g: 0.1, b: 0.1 };
                const colBlue = { r: 0.1, g: 0.3, b: 1 };
                const colPurpleAura = { r: 0.6, g: 0.0, b: 1.0 }; // Deep Violet

                // Optimization: Pre-calc hand positions scalar values
                const lx = (handsData.left.x - 0.5) * 8;
                const ly = -(handsData.left.y - 0.5) * 6;
                const lz = 0; // Simplified Z for attraction target

                const rx = (handsData.right.x - 0.5) * 8;
                const ry = -(handsData.right.y - 0.5) * 6;
                const rz = 0;

                const cx = (lx + rx) / 2;
                const cy = (ly + ry) / 2;
                const cz = 0;

                for (let i = 0; i < this.count; i++) {
                    const idx = i * 3;
                    let pX = positions[idx];
                    let pY = positions[idx+1];
                    let pZ = positions[idx+2];
                    
                    // Logic Switch based on State
                    if (currentState === STATE.EXPLODING) {
                        // --- ENHANCED EXPLOSION LOGIC (Multi-stage Physics) ---
                        
                        const layer = this.randoms[i];
                        let drag = 0.98;
                        if (layer >= 0.6) drag = 0.92; // Shockwave slows down faster
                        
                        // Physics: Apply Velocity directly (units/sec)
                        this.velocities[idx] *= drag;
                        this.velocities[idx+1] *= drag;
                        this.velocities[idx+2] *= 0.995; // Beam sustains momentum
                        
                        pX += this.velocities[idx] * dt;
                        pY += this.velocities[idx+1] * dt;
                        pZ += this.velocities[idx+2] * dt;

                        // Visuals: Duration 4.5s
                        const duration = 4.5;
                        const progress = 1.0 - (cooldownTimer / duration); 
                        
                        if (progress < 0.1) {
                            // Initial Flash: White
                            colors[idx] = 1.0; colors[idx+1] = 1.0; colors[idx+2] = 1.0;
                            sizes[i] = 2.0;
                        } else {
                            // Strobe & Glitch
                            const flicker = Math.sin(appTime * 60.0 + i) > 0;
                            
                            if (layer < 0.2) { 
                                // CORE: White/Violet Strobe
                                if (flicker) { colors[idx]=1; colors[idx+1]=1; colors[idx+2]=1; }
                                else { colors[idx]=0.8; colors[idx+1]=0; colors[idx+2]=1; }
                                sizes[i] = 2.0 * (1.0 - progress); 
                            } else if (layer < 0.6) {
                                // MANTLE: Purple/Cyan Glitch
                                if (Math.random() > 0.97) { 
                                    colors[idx]=0; colors[idx+1]=1; colors[idx+2]=1; // Cyan
                                    sizes[i] = 1.5;
                                } else {
                                    colors[idx]=0.5; colors[idx+1]=0; colors[idx+2]=0.8;
                                    sizes[i] = 0.8 * (1.0 - progress);
                                }
                            } else {
                                // SHOCKWAVE: Dark Violet Fade
                                const waveFade = Math.max(0, 1.0 - progress * 1.5);
                                colors[idx] = 0.4 * waveFade;
                                colors[idx+1] = 0;
                                colors[idx+2] = 0.8 * waveFade;
                                sizes[i] = 3.0 * (progress) * waveFade; 
                            }
                        }

                    } else if (currentState === STATE.COOLDOWN) {
                        // --- COOLDOWN (FADING AURA) ---
                        // Particles continue to drift from explosion momentum but slower
                        this.velocities[idx] *= 0.92; // Heavy drag
                        
                        pX += this.velocities[idx] * dt * 10.0;
                        pY += this.velocities[idx+1] * dt * 10.0;
                        pZ += this.velocities[idx+2] * dt * 10.0;

                        // Slight smoke rise
                        pY += dt * 0.5;

                        // Fade to burnt grey/purple
                        colors[idx] = Math.max(0, colors[idx] * 0.92 - 0.001);
                        colors[idx+1] = Math.max(0, colors[idx+1] * 0.92 - 0.001);
                        colors[idx+2] = Math.max(0, colors[idx+2] * 0.92 - 0.001);

                        // Erratic size decay (smoke dissipation)
                        sizes[i] = sizes[i] * 0.98 + (Math.random() - 0.5) * 0.05;
                        if (sizes[i] < 0) sizes[i] = 0;

                    } else if (currentState === STATE.MERGING) {
                        // --- MERGING VISUALS ---
                        const isLeft = i % 2 === 0;
                        const txTarget = isLeft ? lx : rx;
                        const tyTarget = isLeft ? ly : ry;
                        const tzTarget = isLeft ? lz : rz;
                        
                        const flowSpeed = 2.0; 
                        const lifeOffset = (i % 100) / 100;
                        let t = (appTime * flowSpeed + lifeOffset) % 1.0;

                        // Base Linear Path
                        const vecX = cx - txTarget;
                        const vecY = cy - tyTarget;
                        const vecZ = cz - tzTarget;
                        
                        const helixRadius = 1.0 * (1.0 - t) + 0.1;
                        const spinRate = 15.0;
                        const angle = t * spinRate + i;
                        
                        const perpX = Math.sin(angle) * helixRadius;
                        const perpY = Math.cos(angle) * helixRadius;
                        const perpZ = Math.sin(angle * 2.5) * helixRadius;

                        const tx = txTarget + vecX * t + perpX * 0.5;
                        const ty = tyTarget + vecY * t + perpY * 0.5;
                        const tz = tzTarget + vecZ * t + perpZ * 0.5;

                        pX += (tx - pX) * 0.3;
                        pY += (ty - pY) * 0.3;
                        pZ += (tz - pZ) * 0.3;

                        if (t > 0.8) {
                            const mix = (t - 0.8) * 5.0;
                            colors[idx] = 1.0; 
                            colors[idx+1] = mix; 
                            colors[idx+2] = 1.0;
                            sizes[i] = 0.4 + this.randoms[i] * 0.3;
                        } else {
                            if (isLeft) { colors[idx] = 0.0; colors[idx+1] = 0.2; colors[idx+2] = 1.0; } // Left = Blue
                            else { colors[idx] = 1.0; colors[idx+1] = 0.0; colors[idx+2] = 0.0; } // Right = Red
                            sizes[i] = 0.2;
                        }

                    } else if (currentState === STATE.HOLDING) {
                        // --- HOLLOW PURPLE LOGIC ---
                        const isPrimed = snapPrimed;
                        const compression = isPrimed ? 0.4 : 1.0; 
                        const shake = isPrimed ? 0.05 : 0.0; 

                        const rand = this.randoms[i];
                        const pulse = (1.0 + Math.sin(appTime * 10.0) * 0.15) * compression;

                        // Calculate relative to center
                        if (rand < 0.15) {
                            // Core
                            const r = 0.3 * rand * compression;
                            const theta = appTime * 40.0 + i;
                            const phi = i * 0.1;
                            
                            const tx = cx + Math.sin(theta) * Math.cos(phi) * r;
                            const ty = cy + Math.sin(theta) * Math.sin(phi) * r;
                            const tz = cz + Math.cos(theta) * r;
                            
                            pX += (tx - pX) * 0.8 + (Math.random()-0.5)*shake;
                            pY += (ty - pY) * 0.8 + (Math.random()-0.5)*shake;
                            pZ += (tz - pZ) * 0.8 + (Math.random()-0.5)*shake;
                            
                            colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1;
                            sizes[i] = 0.5 * (isPrimed ? 1.5 : 1.0); 

                        } else if (rand < 0.50) {
                            // Swirl
                            const speed = 4.0;
                            const radius = 1.5 * pulse; 
                            const angle = this.angles[i] + dt * speed;
                            this.angles[i] = angle;
                            
                            const u = angle;
                            const v = angle * 3.0; 
                            
                            const tx = cx + Math.sin(u) * radius * 0.5;
                            const ty = cy + Math.cos(v) * radius; 
                            const tz = cz + Math.cos(u) * radius * 0.5;

                            pX += (tx - pX) * 0.2 + (Math.random()-0.5)*shake;
                            pY += (ty - pY) * 0.2 + (Math.random()-0.5)*shake;
                            pZ += (tz - pZ) * 0.2 + (Math.random()-0.5)*shake;
                            
                            if (isPrimed) { colors[idx] = 1.0; colors[idx+1] = 0.8; colors[idx+2] = 1.0; }
                            else { colors[idx] = 1.0; colors[idx+1] = 0.0; colors[idx+2] = 0.5; }
                            sizes[i] = 0.2;

                        } else {
                            // Outer Aura
                            this.angles[i] += dt * 3.0;
                            const baseScale = 5.0 * compression; 
                            const noise = Math.sin(i * 0.5 + appTime * 8.0);
                            const spike = (rand > 0.98) ? 2.5 : 1.0; 
                            const r = baseScale * spike + noise * 0.4;
                            
                            const tx = cx + Math.cos(this.angles[i] + i) * r;
                            const ty = cy + Math.sin(this.angles[i] + i) * r;
                            const tz = cz + Math.cos(i * 13.0) * r; 
                            
                            const jitter = isPrimed ? 0.3 : 0.15;
                            pX += (tx - pX) * 0.1 + (Math.random()-0.5) * jitter;
                            pY += (ty - pY) * 0.1 + (Math.random()-0.5) * jitter;
                            pZ += (tz - pZ) * 0.1 + (Math.random()-0.5) * jitter;
                            
                            const isVoid = rand > 0.95;
                            if (isVoid) { colors[idx] = 0.05; colors[idx+1] = 0.0; colors[idx+2] = 0.1; } 
                            else { 
                                if (isPrimed) { colors[idx] = 0.8; colors[idx+1] = 0.5; colors[idx+2] = 1.0; } 
                                else { colors[idx] = colPurpleAura.r; colors[idx+1] = colPurpleAura.g; colors[idx+2] = colPurpleAura.b; }
                            }
                            sizes[i] = 0.3 + rand * 0.5;
                        }

                    } else if (currentState === STATE.SINGLE) {
                        const isLeftSet = i % 2 === 0;
                        const hand = isLeftSet ? handsData.left : handsData.right;
                        const txTarget = isLeftSet ? lx : rx;
                        const tyTarget = isLeftSet ? ly : ry;
                        const tzTarget = isLeftSet ? lz : rz;
                        
                        const col = isLeftSet ? colBlue : colRed; 
                        
                        if (hand.present) {
                            if (hand.gesture === 'FIST') {
                                // Vortex Logic
                                const spinDir = isLeftSet ? 1 : -1; 
                                
                                const gravity = 4.0 + (6.0 / (this.radii[i] + 0.1)); 
                                this.radii[i] -= dt * gravity;

                                const spinSpeed = 3.0 + (25.0 / (this.radii[i]*this.radii[i] + 0.1));
                                this.angles[i] += dt * spinDir * spinSpeed;

                                let justRespawned = false;
                                if (this.radii[i] < 0.15) {
                                    this.radii[i] = 8.0 + Math.random() * 6.0; 
                                    this.angles[i] = Math.random() * Math.PI * 2;
                                    justRespawned = true;
                                }
                                
                                const currR = this.radii[i];
                                const diskTilt = (isLeftSet ? -0.3 : 0.3) * currR; 
                                const zWobble = Math.sin(appTime * 8.0 + currR) * 0.15;
                                
                                const tx = txTarget + Math.cos(this.angles[i]) * currR;
                                const ty = tyTarget + Math.sin(this.angles[i]) * currR;
                                const tz = tzTarget + diskTilt + zWobble;

                                if (justRespawned) {
                                    pX = tx; pY = ty; pZ = tz;
                                } else {
                                    const lerpT = 0.5; 
                                    pX += (tx - pX) * lerpT;
                                    pY += (ty - pY) * lerpT;
                                    pZ += (tz - pZ) * lerpT;
                                }

                                const proximity = 1.0 / (currR * 0.5 + 0.2); 
                                sizes[i] = 0.15 + proximity * 0.35; 

                                const edgeFade = Math.min(1.0, Math.max(0, (14.0 - currR) * 0.5)); 
                                const coreHeat = Math.min(1.0, 1.2 / (currR + 0.1)); 

                                // MODIFIED: Reduce white saturation in the core.
                                // Instead of interpolating fully to white (1.0), we only add a fraction of white
                                // to the base color, keeping the core highly saturated (Blue or Red).
                                
                                // Old: colors[idx] = (col.r + (1.0 - col.r) * coreHeat) * edgeFade;
                                // New: Add only 15% of the inverse color to create a "glow" without losing hue.
                                const whiteMix = 0.15;
                                colors[idx] = (col.r + (1.0 - col.r) * coreHeat * whiteMix) * edgeFade * 2.0; // Boosted intensity
                                colors[idx+1] = (col.g + (1.0 - col.g) * coreHeat * whiteMix) * edgeFade * 2.0;
                                colors[idx+2] = (col.b + (1.0 - col.b) * coreHeat * whiteMix) * edgeFade * 2.0;

                            } else {
                                // Shell (Idle Hand)
                                const rotationSpeed = isLeftSet ? 1.5 : -1.5; 
                                this.angles[i] += dt * rotationSpeed;
                                const stableRandom = (i % 100) / 100.0;
                                const targetRadius = 1.2 + stableRandom * 1.5;
                                const diff = targetRadius - this.radii[i];
                                this.radii[i] += diff * dt * 2.0; 
                                const r = this.radii[i];
                                const verticalSway = Math.sin(appTime * 1.5 + i * 0.1) * 0.3;
                                const zPhase = (i % 20) * 0.3;
                                const tx = txTarget + Math.cos(this.angles[i]) * r;
                                const ty = tyTarget + Math.sin(this.angles[i]) * r + verticalSway;
                                const tz = tzTarget + Math.sin(this.angles[i] + zPhase) * (r * 0.6); 
                                pX += (tx - pX) * 0.1; pY += (ty - pY) * 0.1; pZ += (tz - pZ) * 0.1;
                                sizes[i] = 0.2 + Math.sin(appTime * 2.0 + i) * 0.1;
                                colors[idx] = col.r; colors[idx+1] = col.g; colors[idx+2] = col.b;
                            }
                        } else {
                            colors[idx] *= 0.9; colors[idx+1] *= 0.9; colors[idx+2] *= 0.9;
                        }

                    } else {
                        // IDLE
                        pY += dt * 0.5;
                        if (pY > 5) {
                            pY = -5;
                            pX = (Math.random() - 0.5) * 10;
                            pZ = (Math.random() - 0.5) * 5;
                            colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1;
                        }
                        colors[idx] = Math.max(0.2, colors[idx] * 0.99); 
                        colors[idx+1] = Math.max(0.2, colors[idx+1] * 0.99); 
                        colors[idx+2] = Math.max(0.2, colors[idx+2] * 0.99);
                    }

                    positions[idx] = pX;
                    positions[idx+1] = pY;
                    positions[idx+2] = pZ;
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
        }

        // --- GAME LOGIC ---
        function updateLogic() {
            if (!gameStarted) return; // Only process hand logic if game started

            const uiSys = document.getElementById('log-system');

            // --- AUDIO STATE MANAGEMENT ---
            
            // Handle State Audio Transitions
            if (currentState === STATE.MERGING && lastState !== STATE.MERGING) {
                sfx.playMerge();
                sfx.stopHoldLoop();
                sfx.stopChargeLoop();
                sfx.stopRed();
                sfx.stopBlue();
            }
            
            if (currentState === STATE.HOLDING && lastState !== STATE.HOLDING) {
                sfx.startHoldLoop();
            }

            if (currentState === STATE.HOLDING) {
                if (snapPrimed && !lastSnapPrimed) {
                    sfx.stopHoldLoop();
                    sfx.startChargeLoop();
                } else if (!snapPrimed && lastSnapPrimed) {
                    sfx.stopChargeLoop();
                    sfx.startHoldLoop();
                }
            }

            if (currentState === STATE.EXPLODING && lastState !== STATE.EXPLODING) {
                sfx.stopHoldLoop();
                sfx.stopChargeLoop();
                sfx.playExplosion();
            }
            
            if ((currentState === STATE.IDLE || currentState === STATE.SINGLE) && 
                (lastState === STATE.HOLDING || lastState === STATE.MERGING || lastState === STATE.EXPLODING)) {
                sfx.stopHoldLoop();
                sfx.stopChargeLoop();
            }

            // --- RED/BLUE INDIVIDUAL SFX LOGIC ---
            if (currentState === STATE.SINGLE) {
                // Left Hand = Blue
                if (handsData.left.present) {
                    if (handsData.left.gesture === 'FIST') sfx.playBlueFist();
                    else sfx.playBlueOpen();
                } else {
                    sfx.stopBlue();
                }

                // Right Hand = Red
                if (handsData.right.present) {
                    if (handsData.right.gesture === 'FIST') sfx.playRedFist();
                    else sfx.playRedOpen();
                } else {
                    sfx.stopRed();
                }
            } else {
                sfx.stopRed();
                sfx.stopBlue();
            }


            // Update Last States
            lastState = currentState;
            lastSnapPrimed = snapPrimed;


            if (currentState === STATE.COOLDOWN) {
                cooldownTimer -= 0.016; 
                if (cooldownTimer <= 0) {
                    currentState = STATE.IDLE;
                    uiSys.innerText = "SYSTEM: Ready";
                    uiSys.classList.remove('warning');
                    uiSys.style.color = "#0ff";
                }
                return;
            }

            if (currentState === STATE.EXPLODING) {
                cooldownTimer -= 0.016;
                if (cooldownTimer <= 0) {
                    currentState = STATE.COOLDOWN;
                    cooldownTimer = 2.0;
                    uiSys.innerText = "SYSTEM: Cooldown";
                }
                return;
            }

            // Check for Hands
            if (!handsData.left.present && !handsData.right.present) {
                currentState = STATE.IDLE;
                uiSys.innerText = "SYSTEM: Searching Hands...";
                return;
            }

            // Calculate Distance
            const dx = handsData.left.x - handsData.right.x;
            const dy = handsData.left.y - handsData.right.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            handsData.distance = dist;

            // Hand Interaction Logic
            if (handsData.left.present && handsData.right.present) {
                
                // 1. Maintain Holding State
                if (currentState === STATE.HOLDING) {
                     // Break condition: Hands moved too far apart
                     if (dist > CONFIG.breakDistance) {
                         currentState = STATE.SINGLE;
                         snapPrimed = false;
                         uiSys.innerText = "SYSTEM: Connection Lost";
                         uiSys.classList.remove('warning');
                         uiSys.style.color = "#0ff";
                         return;
                     }

                    // Snap Logic: Wait for Pinch then Release
                    const pinch = handsData.right.pinchDist; // Right hand snaps
                    
                    if (pinch < CONFIG.snapThreshold) {
                        snapPrimed = true;
                        uiSys.innerText = "SYSTEM: HOLLOW PURPLE - PRIMED...";
                        uiSys.style.color = "#d0f"; // Visual cue: Purple Text
                    } else if (snapPrimed && pinch > (CONFIG.snapThreshold + 0.05)) {
                        // Released!
                        triggerExplosion();
                        snapPrimed = false;
                        uiSys.style.color = "#0ff";
                    } else if (!snapPrimed) {
                         uiSys.innerText = "SYSTEM: HOLLOW PURPLE - READY (SNAP TO FIRE)";
                         uiSys.style.color = "#0ff";
                    }
                }
                // 2. Maintaining Merging State (waiting for timer)
                else if (currentState === STATE.MERGING) {
                    // Check if hands broke apart too early
                    if (dist > CONFIG.breakDistance) {
                        currentState = STATE.SINGLE;
                        uiSys.innerText = "SYSTEM: Forming Failed";
                        uiSys.classList.remove('warning');
                    }
                }
                // 3. Trigger Merge (From Single or Idle)
                else if (dist < CONFIG.mergeDistance) {
                    currentState = STATE.MERGING;
                    uiSys.innerText = "SYSTEM: HOLLOW PURPLE - FORMING";
                    uiSys.className = "stat-box warning";
                    uiSys.style.color = "#0ff";
                    
                    setTimeout(() => {
                        // Only transition if we haven't broken the state
                        if(currentState === STATE.MERGING) {
                            currentState = STATE.HOLDING;
                            uiSys.innerText = "SYSTEM: HOLLOW PURPLE - READY (SNAP TO FIRE)";
                            snapPrimed = false; 
                        }
                    }, 1000);
                }
                // 4. Default Single State
                else {
                    currentState = STATE.SINGLE;
                    uiSys.innerText = "SYSTEM: Techniques Active (Red/Blue)";
                    uiSys.classList.remove('warning');
                    uiSys.style.color = "#0ff";
                }

            } else {
                // If one hand lost, revert to single
                currentState = STATE.SINGLE; 
                uiSys.innerText = "SYSTEM: Single Technique";
                uiSys.classList.remove('warning');
                uiSys.style.color = "#0ff";
            }
        }

        function triggerExplosion() {
            currentState = STATE.EXPLODING;
            cooldownTimer = 4.5; // Longer duration for the effect
            
            const flash = document.getElementById('flash-overlay');
            flash.style.opacity = 1;
            setTimeout(() => { flash.style.opacity = 0; }, 300);
            
            document.getElementById('log-system').innerText = "SYSTEM: KYOSHIKI MURASAKI (PURPLE)!";
            
            // --- ENHANCED EFFECTS ---
            shakeIntensity = 2.0; // Max Shake
            bloomPass.strength = 10.0; // Blind with light
            
            // Reset particles for explosion
            const positions = particleSystem.geometry.attributes.position.array;
            const count = particleSystem.count;
            
            // Pre-calculate center to explode FROM
            const lx = (handsData.left.x - 0.5) * 8;
            const ly = -(handsData.left.y - 0.5) * 6;
            const rx = (handsData.right.x - 0.5) * 8;
            const ry = -(handsData.right.y - 0.5) * 6;
            const cx = (lx + rx) / 2;
            const cy = (ly + ry) / 2;

            for(let i=0; i<count; i++) {
                const idx = i*3;
                
                // Direction from center
                const dx = positions[idx] - cx;
                const dy = positions[idx+1] - cy;
                const dist = Math.sqrt(dx*dx + dy*dy) + 0.01;
                const angle = Math.atan2(dy, dx);
                
                // Reset Position closer to center to concentrate blast
                positions[idx] = cx + dx * 0.2;
                positions[idx+1] = cy + dy * 0.2;
                positions[idx+2] = (Math.random() - 0.5); // Flat disk start

                const layer = particleSystem.randoms[i];
                
                // VELOCITY SETUP (Units per second approx, will be scaled by dt in update)
                // We use high values because update logic for EXPLODING just does p += v * dt
                
                if (layer < 0.2) {
                    // CORE BEAM (Fastest, straight)
                    const speedZ = 60.0 + Math.random() * 40.0;
                    particleSystem.velocities[idx] = (Math.random()-0.5) * 2.0;
                    particleSystem.velocities[idx+1] = (Math.random()-0.5) * 2.0;
                    particleSystem.velocities[idx+2] = -speedZ;
                } else if (layer < 0.6) {
                    // SPIRAL MANTLE (Twisting energy)
                    const speedZ = 40.0 + Math.random() * 30.0;
                    const expandSpeed = 5.0;
                    const rotSpeed = 20.0; // Tangential force
                    
                    particleSystem.velocities[idx] = Math.cos(angle) * expandSpeed - Math.sin(angle) * rotSpeed;
                    particleSystem.velocities[idx+1] = Math.sin(angle) * expandSpeed + Math.cos(angle) * rotSpeed;
                    particleSystem.velocities[idx+2] = -speedZ;
                } else {
                    // SHOCKWAVE (Expands wide, slower Z)
                    const speedZ = 15.0 + Math.random() * 20.0;
                    const expandSpeed = 25.0 + Math.random() * 15.0;
                    
                    particleSystem.velocities[idx] = Math.cos(angle) * expandSpeed;
                    particleSystem.velocities[idx+1] = Math.sin(angle) * expandSpeed;
                    particleSystem.velocities[idx+2] = -speedZ;
                }
            }
        }

        // --- MEDIAPIPE HANDLER ---
        function onResults(results) {
            lastResults = results; // Store for visualizer loop

            handsData.left.present = false;
            handsData.right.present = false;

            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const label = results.multiHandedness[i].label; 
                    
                    const palm = landmarks[PALM_IDX];
                    const thumbTip = landmarks[THUMB_TIP];
                    const middleTip = landmarks[MIDDLE_TIP];

                    const isFist = (
                        landmarks[8].y > landmarks[6].y && 
                        landmarks[12].y > landmarks[10].y && 
                        landmarks[16].y > landmarks[14].y 
                    );

                    const pinchDx = thumbTip.x - middleTip.x;
                    const pinchDy = thumbTip.y - middleTip.y;
                    const pinchDist = Math.sqrt(pinchDx*pinchDx + pinchDy*pinchDy);

                    const data = (label === 'Left') ? handsData.left : handsData.right;
                    
                    data.present = true;
                    data.x = 1.0 - palm.x; 
                    data.y = palm.y;
                    data.lastGesture = data.gesture; 
                    data.gesture = isFist ? 'FIST' : 'OPEN';
                    data.pinchDist = pinchDist;

                    const logId = (label === 'Left') ? 'log-left' : 'log-right';
                    // ROLE SWAP: Left = Blue, Right = Red
                    const color = (label === 'Left') ? 'Blue' : 'Red';
                    document.getElementById(logId).innerText = 
                        `${label.toUpperCase()} (${color}): ${data.gesture} | Pinch: ${pinchDist.toFixed(2)}`;
                }
            }
        }

        // --- INITIALIZATION ---
        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // FIX: Explicit transparent clear color
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); 
            renderer.setClearColor(0x050505, 1); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
            container.appendChild(renderer.domElement);

            // FIX: Use EffectComposer with transparency support
            const parameters = {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: false
            };
            const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, parameters);

            const renderScene = new THREE.RenderPass(scene, camera);
            
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloomStrength,
                CONFIG.bloomRadius,
                CONFIG.bloomThreshold
            );

            composer = new THREE.EffectComposer(renderer, renderTarget);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            particleSystem = new ParticleEngine(scene);
            handVisualizer = new HandVisualizer(scene);

            const videoElement = document.getElementById('input_video');
            
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            camInstance = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            appTime += 0.02;

            updateLogic();
            particleSystem.update(0.016); 
            
            // Camera Shake logic
            if (currentState === STATE.EXPLODING) {
                 // Sustain bloom and shake for first part of explosion
                 if (cooldownTimer > 1.5) {
                     bloomPass.strength = 6.0 + Math.sin(appTime*50)*2.0; // Strobe
                     shakeIntensity = 0.5; // Constant Rumble
                 } else {
                     shakeIntensity *= 0.95;
                 }
            } else if (shakeIntensity > 0) {
                camera.position.x = (Math.random() - 0.5) * shakeIntensity;
                camera.position.y = (Math.random() - 0.5) * shakeIntensity;
                shakeIntensity *= 0.92; // Decay
                
                // Decay bloom back to normal
                if (bloomPass.strength > CONFIG.bloomStrength) {
                    bloomPass.strength *= 0.95;
                }

                if (shakeIntensity < 0.05) { 
                    shakeIntensity = 0; 
                    camera.position.set(0,0,5); // Reset
                    bloomPass.strength = CONFIG.bloomStrength;
                }
            }

            // Update Virtual Hands
            if (handVisualizer && lastResults) {
                handVisualizer.update(lastResults);
            }

            composer.render();
        }

        init();

    </script>
</body>
</html>
