<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gojo Satoru AR Experience</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Video hidden, used for processing */
        #input_video { display: none; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .warning { color: #f00; text-shadow: 0 0 5px #f00; border-color: #f00; }
        
        /* Flash Effect Overlay */
        #flash-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 99;
            transition: opacity 0.1s ease-out;
        }

        /* Canvas orientation normal (Mirror effect handled by logic) */
        canvas { display: block; }
    </style>

    <!-- 1. Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- 2. Post Processing Dependencies (Order matters for global scripts) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- 3. MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Video Element for MediaPipe (Hidden) -->
    <video id="input_video"></video>

    <!-- UI Logs -->
    <div id="ui-layer">
        <div class="stat-box" id="log-left">LEFT: Searching...</div>
        <div class="stat-box" id="log-right">RIGHT: Searching...</div>
        <div class="stat-box" id="log-system">SYSTEM: Idle</div>
    </div>

    <!-- Screen Flash -->
    <div id="flash-overlay"></div>

    <!-- Main Logic -->
    <script>
        // --- CONSTANTS ---
        const PALM_IDX = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_TIP = 12;
        const RING_TIP = 16;
        const PINKY_TIP = 20;

        const STATE = {
            IDLE: 'IDLE',
            SINGLE: 'SINGLE', // Red/Blue separate
            MERGING: 'MERGING', // Hands close, forming purple
            HOLDING: 'HOLDING', // Purple formed, waiting for snap
            EXPLODING: 'EXPLODING', // Boom
            COOLDOWN: 'COOLDOWN'
        };

        // Configuration
        const CONFIG = {
            particleCount: 6000, 
            mergeDistance: 0.20, // Increased for easier activation (was 0.08)
            breakDistance: 0.40, // Hysteresis: Hands can move apart this much before breaking
            hollowRadius: 0.2, 
            snapThreshold: 0.08, // Threshold for pinch detection
            bloomStrength: 2.5,
            bloomRadius: 0.5,
            bloomThreshold: 0,
        };

        // Global Variables
        let camera, scene, renderer, composer;
        let particleSystem;
        let currentState = STATE.IDLE;
        let snapPrimed = false; // Tracks if user has pinched and is ready to release (snap)
        let appTime = 0;
        let cooldownTimer = 0;
        
        // Hand Data Container
        const handsData = {
            left: { present: false, x: 0, y: 0, gesture: 'OPEN', pinchDist: 1 },
            right: { present: false, x: 0, y: 0, gesture: 'OPEN', pinchDist: 1 },
            distance: 1, // Distance between palms
            center: new THREE.Vector3() // Midpoint
        };

        // --- UTILS: TEXTURE GENERATION ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- PARTICLE SYSTEM ENGINE ---
        class ParticleEngine {
            constructor(scene) {
                this.count = CONFIG.particleCount;
                this.geometry = new THREE.BufferGeometry();
                
                // Attributes
                const positions = new Float32Array(this.count * 3);
                const colors = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);
                
                // Custom data for physics
                this.velocities = new Float32Array(this.count * 3);
                this.angles = new Float32Array(this.count); // For spiraling
                this.radii = new Float32Array(this.count); // Distance from center

                for (let i = 0; i < this.count; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 10;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 5;
                    
                    colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                    sizes[i] = 0.5;
                    this.angles[i] = Math.random() * Math.PI * 2;
                    // Init radii spread out
                    this.radii[i] = 0.5 + Math.random() * 3.0; 
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.PointsMaterial({
                    size: 0.2,
                    map: createGlowTexture(),
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 0.8
                });

                this.mesh = new THREE.Points(this.geometry, material);
                this.mesh.frustumCulled = false; // Always render
                scene.add(this.mesh);
            }

            update(dt) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.color.array;
                const sizes = this.geometry.attributes.size.array;
                
                // Color Definitions
                const colRed = { r: 1, g: 0.1, b: 0.1 };
                const colBlue = { r: 0.1, g: 0.3, b: 1 };
                const colPurple = { r: 0.8, g: 0.2, b: 1 };

                // Pre-calc targets mapped to 3D space
                const mapTo3D = (x, y) => {
                    return {
                        x: (x - 0.5) * 8, // Scale to screen width
                        y: -(y - 0.5) * 6, // Scale to screen height, invert Y
                        z: 0
                    };
                };

                const leftPos = mapTo3D(handsData.left.x, handsData.left.y);
                const rightPos = mapTo3D(handsData.right.x, handsData.right.y);
                const centerPos = mapTo3D(
                    (handsData.left.x + handsData.right.x) / 2, 
                    (handsData.left.y + handsData.right.y) / 2
                );

                for (let i = 0; i < this.count; i++) {
                    const idx = i * 3;
                    let pX = positions[idx];
                    let pY = positions[idx+1];
                    let pZ = positions[idx+2];
                    
                    // Logic Switch based on State
                    if (currentState === STATE.EXPLODING) {
                        // Explosion: Burst outward violently
                        pX += this.velocities[idx] * dt * 20;
                        pY += this.velocities[idx+1] * dt * 20;
                        pZ += this.velocities[idx+2] * dt * 20;
                        sizes[i] *= 0.95; // Fade out

                    } else if (currentState === STATE.HOLDING || currentState === STATE.MERGING) {
                        // Purple Ball Logic
                        const target = centerPos;
                        this.angles[i] += dt * 8; // Super fast spin
                        
                        const r = (currentState === STATE.MERGING) ? 1.5 : 0.6; 
                        const noise = Math.sin(i + appTime * 15) * 0.2;
                        
                        const tx = target.x + Math.cos(this.angles[i] + i) * (r + noise);
                        const ty = target.y + Math.sin(this.angles[i] + i) * (r + noise);
                        const tz = target.z + Math.sin(this.angles[i] * 3) * r; 

                        pX += (tx - pX) * 0.15;
                        pY += (ty - pY) * 0.15;
                        pZ += (tz - pZ) * 0.15;

                        colors[idx] = colPurple.r; colors[idx+1] = colPurple.g; colors[idx+2] = colPurple.b;
                        sizes[i] = 0.4 + Math.random() * 0.3;

                        // Prep velocities for potential explosion
                        this.velocities[idx] = (Math.random() - 0.5);
                        this.velocities[idx+1] = (Math.random() - 0.5);
                        this.velocities[idx+2] = (Math.random() - 0.5);

                    } else if (currentState === STATE.SINGLE) {
                        // Red / Blue Logic
                        const isLeft = i % 2 === 0;
                        const hand = isLeft ? handsData.left : handsData.right;
                        const target = isLeft ? leftPos : rightPos;
                        const col = isLeft ? colRed : colBlue;
                        
                        if (hand.present) {
                            if (hand.gesture === 'FIST') {
                                // --- FIST: UPGRADED VORTEX ACCRETION ---
                                // Simulates a black hole accretion disk with accelerating physics
                                
                                const r = this.radii[i];

                                // 1. Physics: Conservation of angular momentum & Gravity
                                // Closer = Faster spin and Stronger Pull
                                const proximity = 1.0 / (r + 0.1); 
                                
                                // Base Speed + Acceleration curve
                                const spinSpeed = (isLeft ? -3.0 : 3.0) * (1.0 + proximity * 1.5);
                                const pullSpeed = 1.5 + (proximity * 4.0); // Rapidly increasing suction

                                this.angles[i] += dt * spinSpeed;
                                this.radii[i] -= dt * pullSpeed;

                                // 2. Reset to FAR OUTSIDE (Environment spawn)
                                if (this.radii[i] < CONFIG.hollowRadius) {
                                    this.radii[i] = 4.0 + Math.random() * 3.5; // Spawn radius 4.0 - 7.5
                                    this.angles[i] = Math.random() * Math.PI * 2; 
                                }

                                const currR = this.radii[i];
                                
                                const tx = target.x + Math.cos(this.angles[i]) * currR;
                                const ty = target.y + Math.sin(this.angles[i]) * currR;
                                
                                // Tighter follow for snappy, powerful lines
                                pX += (tx - pX) * 0.6; 
                                pY += (ty - pY) * 0.6;
                                pZ += (target.z - pZ) * 0.6;
                                
                                // Size: Large concentration near center, smaller trails outside
                                sizes[i] = 0.15 + (1.0 / (currR + 0.5)) * 0.25;

                            } else {
                                // --- OPEN HAND: ORBITAL SHELL (Lazing/Time-Stop) ---
                                // Particles float in a stable, contained spherical shell around the hand
                                
                                // 1. Rotation: Slower, consistent orbit
                                const rotationSpeed = isLeft ? -1.5 : 1.5; 
                                this.angles[i] += dt * rotationSpeed;

                                // 2. Radius Physics: Drift towards a target shell radius instead of sucking in
                                // Target radius varies per particle to create depth (1.0 to 2.2 range)
                                // Hashing index to get a consistent random radius for this particle
                                const stableRandom = (i % 100) / 100.0;
                                const targetRadius = 1.2 + stableRandom * 1.5;

                                // Smoothly interpolate logical radius towards target
                                const diff = targetRadius - this.radii[i];
                                this.radii[i] += diff * dt * 2.0; 

                                const r = this.radii[i];
                                
                                // 3. Vertical/Depth Oscillation (Levitation feel)
                                const verticalSway = Math.sin(appTime * 1.5 + i * 0.1) * 0.3;
                                
                                // 4. Calculate Target Position on Shell
                                // Create intersecting orbital rings to form a sphere
                                const zPhase = (i % 20) * 0.3; // Distribute phases
                                
                                const tx = target.x + Math.cos(this.angles[i]) * r;
                                const ty = target.y + Math.sin(this.angles[i]) * r + verticalSway;
                                // Tilt the orbit in Z based on the angle and phase to make it spherical
                                const tz = target.z + Math.sin(this.angles[i] + zPhase) * (r * 0.6); 
                                
                                // 5. Soft approach for fluid movement
                                pX += (tx - pX) * 0.1; // Gentle follow factor (0.1) vs Fist (0.6)
                                pY += (ty - pY) * 0.1;
                                pZ += (tz - pZ) * 0.1;
                                
                                // Pulsing glow size
                                sizes[i] = 0.2 + Math.sin(appTime * 2.0 + i) * 0.1;
                            }
                            
                            colors[idx] = col.r; colors[idx+1] = col.g; colors[idx+2] = col.b;

                        } else {
                            // Hand lost: Scatter
                            colors[idx] *= 0.9; colors[idx+1] *= 0.9; colors[idx+2] *= 0.9;
                        }

                    } else {
                        // IDLE
                        pY += dt * 0.5;
                        if (pY > 5) pY = -5;
                        colors[idx] *= 0.95; colors[idx+1] *= 0.95; colors[idx+2] *= 0.95;
                    }

                    positions[idx] = pX;
                    positions[idx+1] = pY;
                    positions[idx+2] = pZ;
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
        }

        // --- GAME LOGIC ---
        function updateLogic() {
            const uiSys = document.getElementById('log-system');

            if (currentState === STATE.COOLDOWN) {
                cooldownTimer -= 0.016; 
                if (cooldownTimer <= 0) {
                    currentState = STATE.IDLE;
                    uiSys.innerText = "SYSTEM: Ready";
                    uiSys.classList.remove('warning');
                    uiSys.style.color = "#0ff";
                }
                return;
            }

            if (currentState === STATE.EXPLODING) {
                cooldownTimer -= 0.016;
                if (cooldownTimer <= 0) {
                    currentState = STATE.COOLDOWN;
                    cooldownTimer = 2.0;
                    uiSys.innerText = "SYSTEM: Cooldown";
                }
                return;
            }

            // Check for Hands
            if (!handsData.left.present && !handsData.right.present) {
                currentState = STATE.IDLE;
                uiSys.innerText = "SYSTEM: Searching Hands...";
                return;
            }

            // Calculate Distance
            const dx = handsData.left.x - handsData.right.x;
            const dy = handsData.left.y - handsData.right.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            handsData.distance = dist;

            // Hand Interaction Logic
            if (handsData.left.present && handsData.right.present) {
                
                // 1. Maintain Holding State
                if (currentState === STATE.HOLDING) {
                     // Break condition: Hands moved too far apart
                     if (dist > CONFIG.breakDistance) {
                         currentState = STATE.SINGLE;
                         snapPrimed = false;
                         uiSys.innerText = "SYSTEM: Connection Lost";
                         uiSys.classList.remove('warning');
                         uiSys.style.color = "#0ff";
                         return;
                     }

                    // Snap Logic: Wait for Pinch then Release
                    const pinch = handsData.right.pinchDist;
                    
                    if (pinch < CONFIG.snapThreshold) {
                        snapPrimed = true;
                        uiSys.innerText = "SYSTEM: HOLLOW PURPLE - PRIMED...";
                        uiSys.style.color = "#d0f"; // Visual cue: Purple Text
                    } else if (snapPrimed && pinch > (CONFIG.snapThreshold + 0.05)) {
                        // Released!
                        triggerExplosion();
                        snapPrimed = false;
                        uiSys.style.color = "#0ff";
                    } else if (!snapPrimed) {
                         uiSys.innerText = "SYSTEM: HOLLOW PURPLE - READY (SNAP TO FIRE)";
                         uiSys.style.color = "#0ff";
                    }
                }
                // 2. Maintaining Merging State (waiting for timer)
                else if (currentState === STATE.MERGING) {
                    // Check if hands broke apart too early
                    if (dist > CONFIG.breakDistance) {
                        currentState = STATE.SINGLE;
                        uiSys.innerText = "SYSTEM: Forming Failed";
                        uiSys.classList.remove('warning');
                    }
                }
                // 3. Trigger Merge (From Single or Idle)
                else if (dist < CONFIG.mergeDistance) {
                    currentState = STATE.MERGING;
                    uiSys.innerText = "SYSTEM: HOLLOW PURPLE - FORMING";
                    uiSys.className = "stat-box warning";
                    uiSys.style.color = "#0ff";
                    
                    setTimeout(() => {
                        // Only transition if we haven't broken the state
                        if(currentState === STATE.MERGING) {
                            currentState = STATE.HOLDING;
                            uiSys.innerText = "SYSTEM: HOLLOW PURPLE - READY (SNAP TO FIRE)";
                            snapPrimed = false; 
                        }
                    }, 1000);
                }
                // 4. Default Single State
                else {
                    currentState = STATE.SINGLE;
                    uiSys.innerText = "SYSTEM: Techniques Active (Red/Blue)";
                    uiSys.classList.remove('warning');
                    uiSys.style.color = "#0ff";
                }

            } else {
                // If one hand lost, revert to single
                currentState = STATE.SINGLE; 
                uiSys.innerText = "SYSTEM: Single Technique";
                uiSys.classList.remove('warning');
                uiSys.style.color = "#0ff";
            }
        }

        function triggerExplosion() {
            currentState = STATE.EXPLODING;
            cooldownTimer = 1.0; 
            
            const flash = document.getElementById('flash-overlay');
            flash.style.opacity = 1;
            setTimeout(() => { flash.style.opacity = 0; }, 100);
            
            document.getElementById('log-system').innerText = "SYSTEM: KYOSHIKI MURASAKI (PURPLE)!";
        }

        // --- MEDIAPIPE HANDLER ---
        function onResults(results) {
            handsData.left.present = false;
            handsData.right.present = false;

            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const label = results.multiHandedness[i].label; 
                    
                    const palm = landmarks[PALM_IDX];
                    const thumbTip = landmarks[THUMB_TIP];
                    const middleTip = landmarks[MIDDLE_TIP];

                    const isFist = (
                        landmarks[8].y > landmarks[6].y && 
                        landmarks[12].y > landmarks[10].y && 
                        landmarks[16].y > landmarks[14].y 
                    );

                    const pinchDx = thumbTip.x - middleTip.x;
                    const pinchDy = thumbTip.y - middleTip.y;
                    const pinchDist = Math.sqrt(pinchDx*pinchDx + pinchDy*pinchDy);

                    const data = (label === 'Left') ? handsData.left : handsData.right;
                    
                    data.present = true;
                    data.x = 1.0 - palm.x; 
                    data.y = palm.y;
                    data.gesture = isFist ? 'FIST' : 'OPEN';
                    data.pinchDist = pinchDist;

                    const logId = (label === 'Left') ? 'log-left' : 'log-right';
                    const color = (label === 'Left') ? 'Red' : 'Blue';
                    document.getElementById(logId).innerText = 
                        `${label.toUpperCase()} (${color}): ${data.gesture} | Pinch: ${pinchDist.toFixed(2)}`;
                }
            }
        }

        // --- INITIALIZATION ---
        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloomStrength,
                CONFIG.bloomRadius,
                CONFIG.bloomThreshold
            );

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            particleSystem = new ParticleEngine(scene);

            const videoElement = document.getElementById('input_video');
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            const cam = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cam.start();

            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            appTime += 0.02;

            updateLogic();
            particleSystem.update(0.016); 
            composer.render();
        }

        init();

    </script>
</body>
</html>