<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gojo Satoru AR Experience</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        /* Container ensures canvas is on top */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }
        
        /* Video Background (Toggleable Mini-Window) */
        #input_video { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 320px; 
            height: 240px; 
            object-fit: cover; 
            z-index: 50; /* On top of everything */
            transform: scaleX(-1); /* Mirror effect */
            display: none; /* Hidden by default */
            border-radius: 12px;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            filter: grayscale(100%) contrast(1.2) brightness(0.8);
        }
        
        /* Landing Page Overlay */
        #landing-page {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); /* Semi-transparent to see particles */
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s ease-out;
        }
        .landing-content {
            max-width: 900px;
            padding: 30px;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #333;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
            border-radius: 4px;
        }
        #landing-page h1 { color: #0ff; text-shadow: 0 0 15px #0ff; margin: 0 0 10px 0; font-size: 2.5rem; letter-spacing: 4px; }
        #landing-page .subtitle { color: #888; margin-bottom: 40px; font-size: 1rem; letter-spacing: 2px; text-transform: uppercase; }
        
        .tutorial-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 40px;
            text-align: left;
        }
        @media (max-width: 768px) {
            .tutorial-grid { grid-template-columns: 1fr; }
            #landing-page h1 { font-size: 1.8rem; }
        }
        .tutorial-card {
            border: 1px solid #333;
            padding: 20px;
            background: rgba(0,0,0,0.6);
            transition: transform 0.2s;
        }
        .tutorial-card:hover { border-color: #555; transform: translateY(-2px); }
        .tutorial-card h3 { color: #d0f; font-size: 1.1rem; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 10px; }
        .tutorial-card p { font-size: 0.9rem; color: #ccc; line-height: 1.5; margin: 0; }
        .key-highlight { color: #fff; font-weight: bold; }

        .info-note { margin-bottom: 30px; color: #0ff; font-size: 0.9rem; border-top: 1px solid #333; padding-top: 20px; width: 100%; }

        #start-btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: 0.3s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            font-weight: bold;
        }
        #start-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
        }
        .credits-small { margin-top: 20px; font-size: 0.8rem; color: #444; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
            display: none; /* Hidden until start */
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .warning { color: #f00; text-shadow: 0 0 5px #f00; border-color: #f00; }
        
        /* Flash Effect Overlay */
        #flash-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 99;
            transition: opacity 0.1s ease-out;
        }

        /* Credits & Controls */
        #credit {
            position: absolute;
            top: 10px;
            right: 15px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 10px;
            z-index: 20;
            pointer-events: none;
            letter-spacing: 1px;
            display: none; /* Hidden until start */
        }

        #controls {
            position: absolute;
            top: 30px;
            right: 15px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            display: none; /* Hidden until start */
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #444;
            color: #888;
            padding: 6px 12px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            transition: all 0.3s;
            pointer-events: auto;
            text-transform: uppercase;
            width: 100px;
            text-align: center;
        }
        
        .control-btn.active {
            border-color: #0ff;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            background: rgba(0, 50, 50, 0.6);
        }

        .control-btn:hover {
            background: rgba(30, 30, 30, 0.8);
        }

        /* Canvas orientation */
        canvas { 
            display: block; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 5; /* Ensure canvas is above video */
        }
    </style>

    <!-- 1. Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- 2. Post Processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- 3. MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Video Element for MediaPipe -->
    <video id="input_video"></video>
    
    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Landing Page -->
    <div id="landing-page">
        <div class="landing-content">
            <h1>DOMAIN EXPANSION: AR</h1>
            <p class="subtitle">Gojo Satoru Cursed Technique Simulation</p>
            
            <div class="tutorial-grid">
                <div class="tutorial-card">
                    <h3>1. BLUE & RED</h3>
                    <p>Show your hands to activate techniques.<br>
                    <span class="key-highlight">Left Hand</span> = Reversal Red<br>
                    <span class="key-highlight">Right Hand</span> = Lapse Blue</p>
                </div>
                <div class="tutorial-card">
                    <h3>2. HOLLOW PURPLE</h3>
                    <p>Bring your <span class="key-highlight">palms close together</span> to merge the red and blue energies into the imaginary mass.</p>
                </div>
                <div class="tutorial-card">
                    <h3>3. SNAP TO FIRE</h3>
                    <p>While holding Purple, <span class="key-highlight">PINCH</span> (Thumb + Middle) and <span class="key-highlight">RELEASE</span> quickly to launch the attack.</p>
                </div>
            </div>

            <div class="info-note">
                <p>Use the <strong>CAM: ON</strong> toggle to open a reference monitor.</p>
            </div>

            <button id="start-btn" onclick="startGame()">ENTER VOID</button>
            <div class="credits-small">Created by HyIsNoob</div>
        </div>
    </div>

    <!-- UI Logs -->
    <div id="ui-layer">
        <div class="stat-box" id="log-left">LEFT: Searching...</div>
        <div class="stat-box" id="log-right">RIGHT: Searching...</div>
        <div class="stat-box" id="log-system">SYSTEM: Idle</div>
    </div>

    <!-- Credits & Controls -->
    <div id="credit">HyIsNoob</div>
    <div id="controls">
        <button id="btn-cam" class="control-btn" onclick="toggleCamera()">Cam: OFF</button>
        <button id="btn-log" class="control-btn active" onclick="toggleLogs()">Logs: ON</button>
    </div>

    <!-- Screen Flash -->
    <div id="flash-overlay"></div>

    <!-- Main Logic -->
    <script>
        // --- CONSTANTS ---
        const PALM_IDX = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_TIP = 12;
        const RING_TIP = 16;
        const PINKY_TIP = 20;

        const STATE = {
            IDLE: 'IDLE',
            SINGLE: 'SINGLE', // Red/Blue separate
            MERGING: 'MERGING', // Hands close, forming purple
            HOLDING: 'HOLDING', // Purple formed, waiting for snap
            EXPLODING: 'EXPLODING', // Boom
            COOLDOWN: 'COOLDOWN'
        };

        // Configuration
        const CONFIG = {
            particleCount: 6500, // Slight increase for density
            mergeDistance: 0.20,
            breakDistance: 0.40,
            hollowRadius: 0.2, 
            snapThreshold: 0.08, 
            bloomStrength: 3.5, 
            bloomRadius: 0.6,
            bloomThreshold: 0,
        };

        // Global Variables
        let camera, scene, renderer, composer;
        let particleSystem;
        let currentState = STATE.IDLE;
        let lastState = STATE.IDLE; // To track transitions
        let snapPrimed = false; 
        let lastSnapPrimed = false;
        let appTime = 0;
        let cooldownTimer = 0;
        let gameStarted = false; // Flag to check if start button pressed
        let camInstance = null; // Camera instance
        
        // Hand Data Container
        const handsData = {
            left: { present: false, x: 0, y: 0, gesture: 'OPEN', lastGesture: 'NONE', pinchDist: 1 },
            right: { present: false, x: 0, y: 0, gesture: 'OPEN', lastGesture: 'NONE', pinchDist: 1 },
            distance: 1, 
            center: new THREE.Vector3() 
        };

        // --- SOUND MANAGER (Web Audio API) ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.loops = {
                    hold: null,
                    charge: null
                };
                
                // Track active SFX states to avoid spamming start calls
                this.activeStates = {
                    red: 'NONE',  // 'OPEN', 'FIST', 'NONE'
                    blue: 'NONE'
                };
            }

            init() {
                if (this.initialized) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.4;
                this.masterGain.connect(this.ctx.destination);
                this.initialized = true;
                
                // Warm up
                this.ctx.resume();
            }

            // --- RED TECHNIQUE PLACEHOLDERS ---
            playRedOpen() {
                if (this.activeStates.red === 'OPEN') return;
                this.stopRed(); // Clean up prev
                this.activeStates.red = 'OPEN';
                console.log("SFX: Start RED OPEN loop");
                // TODO: Add your Red Open sound code here
            }

            playRedFist() {
                if (this.activeStates.red === 'FIST') return;
                this.stopRed(); // Clean up prev
                this.activeStates.red = 'FIST';
                console.log("SFX: Start RED FIST loop");
                // TODO: Add your Red Fist sound code here
            }

            stopRed() {
                if (this.activeStates.red === 'NONE') return;
                console.log("SFX: Stop RED loop");
                this.activeStates.red = 'NONE';
                // TODO: Stop any active Red sounds here
            }

            // --- BLUE TECHNIQUE PLACEHOLDERS ---
            playBlueOpen() {
                if (this.activeStates.blue === 'OPEN') return;
                this.stopBlue(); // Clean up prev
                this.activeStates.blue = 'OPEN';
                console.log("SFX: Start BLUE OPEN loop");
                // TODO: Add your Blue Open sound code here
            }

            playBlueFist() {
                if (this.activeStates.blue === 'FIST') return;
                this.stopBlue(); // Clean up prev
                this.activeStates.blue = 'FIST';
                console.log("SFX: Start BLUE FIST loop");
                // TODO: Add your Blue Fist sound code here
            }

            stopBlue() {
                if (this.activeStates.blue === 'NONE') return;
                console.log("SFX: Stop BLUE loop");
                this.activeStates.blue = 'NONE';
                // TODO: Stop any active Blue sounds here
            }

            // --- CORE SFX ---
            // Procedural Merge Sound (Energy gathering)
            playMerge() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc1.frequency.setValueAtTime(100, t);
                osc1.frequency.exponentialRampToValueAtTime(600, t + 1.0);
                
                osc2.frequency.setValueAtTime(800, t);
                osc2.frequency.exponentialRampToValueAtTime(600, t + 1.0);

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.5, t + 0.5);
                gain.gain.linearRampToValueAtTime(0, t + 1.2);

                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(this.masterGain);

                osc1.start(t);
                osc2.start(t);
                osc1.stop(t + 1.2);
                osc2.stop(t + 1.2);
            }

            startHoldLoop() {
                if (!this.ctx || this.loops.hold) return;
                const t = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();

                // Heavy Bass Drone
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(55, t); // Low A

                // LFO for instability/throbbing
                lfo.frequency.setValueAtTime(8, t); // 8Hz flutter
                lfoGain.gain.value = 50; // Modulate frequency slightly

                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.2, t + 1);

                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                lfo.start(t);

                this.loops.hold = { nodes: [osc, gain, lfo, lfoGain] };
            }

            stopHoldLoop() {
                if (this.loops.hold) {
                    const t = this.ctx.currentTime;
                    const { nodes } = this.loops.hold;
                    // Fade out
                    nodes[1].gain.cancelScheduledValues(t);
                    nodes[1].gain.linearRampToValueAtTime(0, t + 0.2);
                    
                    setTimeout(() => {
                        nodes.forEach(n => { try{ n.stop(); }catch(e){} try{ n.disconnect(); }catch(e){} });
                    }, 250);
                    this.loops.hold = null;
                }
            }

            startChargeLoop() {
                if (!this.ctx || this.loops.charge) return;
                const t = this.ctx.currentTime;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(800, t + 3); // Rising tension

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3, t + 0.1);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                this.loops.charge = { nodes: [osc, gain] };
            }

            stopChargeLoop() {
                if (this.loops.charge) {
                    const t = this.ctx.currentTime;
                    const { nodes } = this.loops.charge;
                    nodes[1].gain.cancelScheduledValues(t);
                    nodes[1].gain.linearRampToValueAtTime(0, t + 0.1);
                    setTimeout(() => {
                        nodes.forEach(n => { try{ n.stop(); }catch(e){} try{ n.disconnect(); }catch(e){} });
                    }, 150);
                    this.loops.charge = null;
                }
            }

            playExplosion() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                // 1. Noise Burst
                const bufferSize = this.ctx.sampleRate * 2.0;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1);
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                // Filter the noise to sound like a boom, not hiss
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, t);
                filter.frequency.exponentialRampToValueAtTime(100, t + 1);

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(2.0, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 1.5);

                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                noise.start(t);

                // 2. Sub Drop (The "Impact")
                const sub = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                sub.frequency.setValueAtTime(150, t);
                sub.frequency.exponentialRampToValueAtTime(10, t + 1);
                
                subGain.gain.setValueAtTime(1.0, t);
                subGain.gain.exponentialRampToValueAtTime(0.01, t + 1);

                sub.connect(subGain);
                subGain.connect(this.masterGain);
                sub.start(t);
                sub.stop(t + 1);
            }
        }

        const sfx = new SoundManager();

        // --- UTILS: TEXTURE GENERATION ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- CONTROLS LOGIC ---
        function toggleCamera() {
            const video = document.getElementById('input_video');
            const btn = document.getElementById('btn-cam');
            if (video.style.display === 'block') {
                video.style.display = 'none';
                btn.innerText = 'CAM: OFF';
                btn.classList.remove('active');
            } else {
                video.style.display = 'block';
                btn.innerText = 'CAM: ON';
                btn.classList.add('active');
            }
        }

        function toggleLogs() {
            const ui = document.getElementById('ui-layer');
            const btn = document.getElementById('btn-log');
            if (ui.style.display === 'none') {
                ui.style.display = 'block';
                btn.innerText = 'LOGS: ON';
                btn.classList.add('active');
            } else {
                ui.style.display = 'none';
                btn.innerText = 'LOGS: OFF';
                btn.classList.remove('active');
            }
        }

        // --- START GAME LOGIC ---
        function startGame() {
            const landing = document.getElementById('landing-page');
            landing.style.opacity = '0';
            setTimeout(() => { landing.style.display = 'none'; }, 500);

            // Show UI elements
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('credit').style.display = 'block';
            document.getElementById('controls').style.display = 'flex';

            // Init Audio
            sfx.init();

            gameStarted = true;
            if (camInstance) {
                camInstance.start();
            }
        }

        // --- PARTICLE SYSTEM ENGINE ---
        class ParticleEngine {
            constructor(scene) {
                this.count = CONFIG.particleCount;
                this.geometry = new THREE.BufferGeometry();
                
                // Attributes
                const positions = new Float32Array(this.count * 3);
                const colors = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);
                
                // Custom data for physics
                this.velocities = new Float32Array(this.count * 3);
                this.angles = new Float32Array(this.count); // For spiraling
                this.radii = new Float32Array(this.count); // Distance from center
                this.randoms = new Float32Array(this.count); // Static random for deterministic role assignment

                for (let i = 0; i < this.count; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 10;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 5;
                    
                    colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                    sizes[i] = 0.5;
                    this.angles[i] = Math.random() * Math.PI * 2;
                    // Init radii spread out
                    this.radii[i] = 0.5 + Math.random() * 3.0; 
                    this.randoms[i] = Math.random();
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.PointsMaterial({
                    size: 0.2,
                    map: createGlowTexture(),
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 0.8
                });

                this.mesh = new THREE.Points(this.geometry, material);
                this.mesh.frustumCulled = false; // Always render
                scene.add(this.mesh);
            }

            update(dt) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.color.array;
                const sizes = this.geometry.attributes.size.array;
                
                // Color Definitions
                const colRed = { r: 1, g: 0.1, b: 0.1 };
                const colBlue = { r: 0.1, g: 0.3, b: 1 };
                // Enhanced Purple colors
                const colPurpleAura = { r: 0.6, g: 0.0, b: 1.0 }; // Deep Violet
                const colCyan = { r: 0.2, g: 0.9, b: 1.0 }; 

                // Pre-calc targets mapped to 3D space
                const mapTo3D = (x, y) => {
                    return {
                        x: (x - 0.5) * 8, // Scale to screen width
                        y: -(y - 0.5) * 6, // Scale to screen height, invert Y
                        z: 0
                    };
                };

                const leftPos = mapTo3D(handsData.left.x, handsData.left.y);
                const rightPos = mapTo3D(handsData.right.x, handsData.right.y);
                const centerPos = mapTo3D(
                    (handsData.left.x + handsData.right.x) / 2, 
                    (handsData.left.y + handsData.right.y) / 2
                );

                for (let i = 0; i < this.count; i++) {
                    const idx = i * 3;
                    let pX = positions[idx];
                    let pY = positions[idx+1];
                    let pZ = positions[idx+2];
                    
                    // Logic Switch based on State
                    if (currentState === STATE.EXPLODING) {
                        // Explosion logic
                        pX += this.velocities[idx] * dt * 50;
                        pY += this.velocities[idx+1] * dt * 50;
                        pZ += this.velocities[idx+2] * dt * 50;
                        sizes[i] *= 0.92;

                    } else if (currentState === STATE.MERGING) {
                        // --- IMPROVED MERGING VISUALS ---
                        const isRed = i % 2 === 0;
                        const sourcePos = isRed ? leftPos : rightPos;
                        
                        // Helix Calculation
                        const flowSpeed = 2.0; // Faster merge
                        const lifeOffset = (i % 100) / 100;
                        let t = (appTime * flowSpeed + lifeOffset) % 1.0;
                        // t = 0 (hand) -> 1 (center)

                        // Base Linear Path
                        const vecX = centerPos.x - sourcePos.x;
                        const vecY = centerPos.y - sourcePos.y;
                        const vecZ = centerPos.z - sourcePos.z;
                        
                        // Helix Radius (Wide at hand, tight at center)
                        const helixRadius = 1.0 * (1.0 - t) + 0.1;
                        // Spin
                        const spinRate = 15.0;
                        const angle = t * spinRate + i;
                        
                        // Perpendicular vectors for 3D rotation around the path
                        // Simplified: rotate around Z axis relative to path? 
                        // Just adding simple trig noise perpendicular to motion is easier and looks good
                        const perpX = Math.sin(angle) * helixRadius;
                        const perpY = Math.cos(angle) * helixRadius;
                        const perpZ = Math.sin(angle * 2.5) * helixRadius;

                        // Target Position
                        const tx = sourcePos.x + vecX * t + perpX * 0.5;
                        const ty = sourcePos.y + vecY * t + perpY * 0.5;
                        const tz = sourcePos.z + vecZ * t + perpZ * 0.5;

                        // Lerp for smoothness
                        pX += (tx - pX) * 0.3;
                        pY += (ty - pY) * 0.3;
                        pZ += (tz - pZ) * 0.3;

                        // Dynamic Color Mixing
                        // Starts Pure Red/Blue -> Becomes Violet/White at center (t > 0.8)
                        if (t > 0.8) {
                            const mix = (t - 0.8) * 5.0; // 0 to 1
                            colors[idx] = 1.0; // White hot
                            colors[idx+1] = mix; 
                            colors[idx+2] = 1.0;
                            sizes[i] = 0.4 + Math.random() * 0.3;
                        } else {
                            if (isRed) { colors[idx] = 1.0; colors[idx+1] = 0.0; colors[idx+2] = 0.0; }
                            else { colors[idx] = 0.0; colors[idx+1] = 0.2; colors[idx+2] = 1.0; }
                            sizes[i] = 0.2;
                        }

                    } else if (currentState === STATE.HOLDING) {
                        // --- HOLLOW PURPLE LOGIC (Enhanced Center) ---
                        const target = centerPos;
                        
                        // PRIMED EFFECT: Compression
                        // If Primed, reduce radius, increase shake
                        const isPrimed = snapPrimed;
                        const compression = isPrimed ? 0.4 : 1.0; // Shrink to 40% size
                        const shake = isPrimed ? 0.05 : 0.0; 

                        const rand = this.randoms[i];
                        const pulse = (1.0 + Math.sin(appTime * 15.0) * 0.05) * compression;

                        if (rand < 0.08) {
                            // --- LAYER 1: SINGULARITY ---
                            const theta = appTime * 30 + i;
                            const phi = i * 0.5;
                            const r = 0.1 * Math.random() * pulse; 
                            
                            const tx = target.x + Math.sin(theta) * Math.cos(phi) * r;
                            const ty = target.y + Math.sin(theta) * Math.sin(phi) * r;
                            const tz = target.z + Math.cos(theta) * r;
                            
                            pX += (tx - pX) * 0.6 + (Math.random()-0.5)*shake; 
                            pY += (ty - pY) * 0.6 + (Math.random()-0.5)*shake; 
                            pZ += (tz - pZ) * 0.6 + (Math.random()-0.5)*shake;
                            
                            // Primed: Pure White
                            if (isPrimed) { colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1; }
                            else { colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1; }
                            sizes[i] = (0.5 + Math.random() * 0.3) * (isPrimed ? 2.0 : 1.0); // Brighter
                            
                        } else if (rand < 0.20) {
                             // --- LAYER 2: EVENT HORIZON ---
                             const speed = 15.0;
                             const radius = 0.4 * pulse;
                             const angle = this.angles[i] + dt * speed;
                             this.angles[i] = angle;
                             
                             const tx = target.x + Math.cos(angle) * radius;
                             const ty = target.y + Math.sin(angle) * radius * 0.8; 
                             const tz = target.z + Math.sin(angle * 2.0) * 0.1; 

                             pX += (tx - pX) * 0.3 + (Math.random()-0.5)*shake;
                             pY += (ty - pY) * 0.3 + (Math.random()-0.5)*shake;
                             pZ += (tz - pZ) * 0.3 + (Math.random()-0.5)*shake;

                             if (isPrimed) { colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1; }
                             else { colors[idx] = 0.5; colors[idx+1] = 0.0; colors[idx+2] = 1.0; }
                             sizes[i] = 0.3;

                        } else if (rand < 0.35) {
                            // --- LAYER 3: MAGNETIC FILAMENTS ---
                            const speed = 2.0;
                            const radius = 0.8 * pulse;
                            const angle = this.angles[i] + dt * speed;
                            this.angles[i] = angle;
                            
                            const u = angle;
                            const v = angle * 3.0; 
                            
                            const tx = target.x + Math.sin(u) * radius * 0.5;
                            const ty = target.y + Math.cos(v) * radius; 
                            const tz = target.z + Math.cos(u) * radius * 0.5;

                            pX += (tx - pX) * 0.2 + (Math.random()-0.5)*shake;
                            pY += (ty - pY) * 0.2 + (Math.random()-0.5)*shake;
                            pZ += (tz - pZ) * 0.2 + (Math.random()-0.5)*shake;
                            
                            if (isPrimed) { colors[idx] = 1.0; colors[idx+1] = 0.8; colors[idx+2] = 1.0; }
                            else { colors[idx] = 1.0; colors[idx+1] = 0.0; colors[idx+2] = 0.5; }
                            sizes[i] = 0.15;

                        } else {
                            // --- LAYER 4: OUTER AURA ---
                            this.angles[i] += dt * 3.0;
                            const baseScale = 3.5 * compression; // Aura also compresses
                            const noise = Math.sin(i * 0.5 + appTime * 8.0);
                            const spike = (Math.random() > 0.98) ? 2.5 : 1.0; 
                            const r = baseScale * spike + noise * 0.4;
                            
                            const tx = target.x + Math.cos(this.angles[i] + i) * r;
                            const ty = target.y + Math.sin(this.angles[i] + i) * r;
                            const tz = target.z + Math.cos(i * 13.0) * r; 
                            
                            const jitter = isPrimed ? 0.3 : 0.15; // More jitter
                            pX += (tx - pX) * 0.1 + (Math.random()-0.5) * jitter;
                            pY += (ty - pY) * 0.1 + (Math.random()-0.5) * jitter;
                            pZ += (tz - pZ) * 0.1 + (Math.random()-0.5) * jitter;
                            
                            const isVoid = Math.random() > 0.95;
                            if (isVoid) { colors[idx] = 0.05; colors[idx+1] = 0.0; colors[idx+2] = 0.1; } 
                            else { 
                                if (isPrimed) { colors[idx] = 0.8; colors[idx+1] = 0.5; colors[idx+2] = 1.0; } // Brighter violet
                                else { colors[idx] = colPurpleAura.r; colors[idx+1] = colPurpleAura.g; colors[idx+2] = colPurpleAura.b; }
                            }
                            sizes[i] = 0.2 + Math.random() * 0.4;
                        }

                        // Prep explosion velocities
                        const dirX = pX - target.x; const dirY = pY - target.y; const dirZ = pZ - target.z;
                        const len = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ) + 0.001;
                        this.velocities[idx] = (dirX / len) + (Math.random()-0.5)*0.5;
                        this.velocities[idx+1] = (dirY / len) + (Math.random()-0.5)*0.5;
                        this.velocities[idx+2] = (dirZ / len) + (Math.random()-0.5)*0.5;

                    } else if (currentState === STATE.SINGLE) {
                        // Red / Blue Logic
                        const isLeft = i % 2 === 0;
                        const hand = isLeft ? handsData.left : handsData.right;
                        const target = isLeft ? leftPos : rightPos;
                        const col = isLeft ? colRed : colBlue;
                        
                        if (hand.present) {
                            if (hand.gesture === 'FIST') {
                                // IMPROVED: Black Hole / Vortex Accretion
                                const spinDir = isLeft ? -1 : 1;
                                
                                // 1. Accelerate Suction (Gravity)
                                // Far away = slower, Close = very fast
                                const gravity = 4.0 + (6.0 / (this.radii[i] + 0.1)); 
                                this.radii[i] -= dt * gravity;

                                // 2. Accelerate Spin (Conservation of Angular Momentum)
                                const spinSpeed = 3.0 + (25.0 / (this.radii[i]*this.radii[i] + 0.1));
                                this.angles[i] += dt * spinDir * spinSpeed;

                                // 3. Respawn / Event Horizon
                                let justRespawned = false;
                                if (this.radii[i] < 0.15) {
                                    this.radii[i] = 8.0 + Math.random() * 6.0; // Wide spawn range
                                    this.angles[i] = Math.random() * Math.PI * 2;
                                    justRespawned = true;
                                }
                                
                                const currR = this.radii[i];
                                
                                // 4. Target Calculation with Z-Vortex
                                const diskTilt = (isLeft ? 0.3 : -0.3) * currR; // Tilt the disk
                                const zWobble = Math.sin(appTime * 8.0 + currR) * 0.15;
                                
                                const tx = target.x + Math.cos(this.angles[i]) * currR;
                                const ty = target.y + Math.sin(this.angles[i]) * currR;
                                const tz = target.z + diskTilt + zWobble;

                                // 5. Position Update
                                if (justRespawned) {
                                    // Teleport to start to prevent outward streaks -> Pure suction look
                                    pX = tx; pY = ty; pZ = tz;
                                } else {
                                    // High lerp for tight spiral following
                                    const lerpT = 0.5; 
                                    pX += (tx - pX) * lerpT;
                                    pY += (ty - pY) * lerpT;
                                    pZ += (tz - pZ) * lerpT;
                                }

                                // 6. Appearance
                                // Size: Large chunks at center, dust at edges
                                const proximity = 1.0 / (currR * 0.5 + 0.2); 
                                sizes[i] = 0.15 + proximity * 0.35; 

                                // Color: Fade in at edges, White hot at center
                                const edgeFade = Math.min(1.0, Math.max(0, (14.0 - currR) * 0.5)); // Alpha fade in
                                const coreHeat = Math.min(1.0, 1.2 / (currR + 0.1)); // White mix

                                colors[idx] = (col.r + (1.0 - col.r) * coreHeat) * edgeFade;
                                colors[idx+1] = (col.g + (1.0 - col.g) * coreHeat) * edgeFade;
                                colors[idx+2] = (col.b + (1.0 - col.b) * coreHeat) * edgeFade;

                            } else {
                                // Shell
                                const rotationSpeed = isLeft ? -1.5 : 1.5; 
                                this.angles[i] += dt * rotationSpeed;
                                const stableRandom = (i % 100) / 100.0;
                                const targetRadius = 1.2 + stableRandom * 1.5;
                                const diff = targetRadius - this.radii[i];
                                this.radii[i] += diff * dt * 2.0; 
                                const r = this.radii[i];
                                const verticalSway = Math.sin(appTime * 1.5 + i * 0.1) * 0.3;
                                const zPhase = (i % 20) * 0.3;
                                const tx = target.x + Math.cos(this.angles[i]) * r;
                                const ty = target.y + Math.sin(this.angles[i]) * r + verticalSway;
                                const tz = target.z + Math.sin(this.angles[i] + zPhase) * (r * 0.6); 
                                pX += (tx - pX) * 0.1; pY += (ty - pY) * 0.1; pZ += (tz - pZ) * 0.1;
                                sizes[i] = 0.2 + Math.sin(appTime * 2.0 + i) * 0.1;
                                colors[idx] = col.r; colors[idx+1] = col.g; colors[idx+2] = col.b;
                            }
                        } else {
                             // Scatter
                            colors[idx] *= 0.9; colors[idx+1] *= 0.9; colors[idx+2] *= 0.9;
                        }

                    } else {
                        // IDLE / BACKGROUND MODE
                        // Particles drift gently for the landing page background
                        pY += dt * 0.5;
                        if (pY > 5) {
                            pY = -5;
                            pX = (Math.random() - 0.5) * 10;
                            pZ = (Math.random() - 0.5) * 5;
                            // Reset brightness for loop
                            colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1;
                        }
                        // Gentle fade but keep them visible
                        colors[idx] = Math.max(0.2, colors[idx] * 0.99); 
                        colors[idx+1] = Math.max(0.2, colors[idx+1] * 0.99); 
                        colors[idx+2] = Math.max(0.2, colors[idx+2] * 0.99);
                    }

                    positions[idx] = pX;
                    positions[idx+1] = pY;
                    positions[idx+2] = pZ;
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
        }

        // --- GAME LOGIC ---
        function updateLogic() {
            if (!gameStarted) return; // Only process hand logic if game started

            const uiSys = document.getElementById('log-system');

            // --- AUDIO STATE MANAGEMENT ---
            
            // Handle State Audio Transitions
            if (currentState === STATE.MERGING && lastState !== STATE.MERGING) {
                sfx.playMerge();
                sfx.stopHoldLoop();
                sfx.stopChargeLoop();
                // Ensure Single Hand SFX are stopped
                sfx.stopRed();
                sfx.stopBlue();
            }
            
            if (currentState === STATE.HOLDING && lastState !== STATE.HOLDING) {
                sfx.startHoldLoop();
            }

            if (currentState === STATE.HOLDING) {
                if (snapPrimed && !lastSnapPrimed) {
                    sfx.stopHoldLoop();
                    sfx.startChargeLoop();
                } else if (!snapPrimed && lastSnapPrimed) {
                    sfx.stopChargeLoop();
                    sfx.startHoldLoop();
                }
            }

            if (currentState === STATE.EXPLODING && lastState !== STATE.EXPLODING) {
                sfx.stopHoldLoop();
                sfx.stopChargeLoop();
                sfx.playExplosion();
            }
            
            if ((currentState === STATE.IDLE || currentState === STATE.SINGLE) && 
                (lastState === STATE.HOLDING || lastState === STATE.MERGING || lastState === STATE.EXPLODING)) {
                sfx.stopHoldLoop();
                sfx.stopChargeLoop();
            }

            // --- RED/BLUE INDIVIDUAL SFX LOGIC ---
            if (currentState === STATE.SINGLE) {
                // Left Hand (Red)
                if (handsData.left.present) {
                    if (handsData.left.gesture === 'FIST') sfx.playRedFist();
                    else sfx.playRedOpen();
                } else {
                    sfx.stopRed();
                }

                // Right Hand (Blue)
                if (handsData.right.present) {
                    if (handsData.right.gesture === 'FIST') sfx.playBlueFist();
                    else sfx.playBlueOpen();
                } else {
                    sfx.stopBlue();
                }
            } else {
                // If not in single mode (e.g. merging, holding), ensure single SFX are off
                sfx.stopRed();
                sfx.stopBlue();
            }


            // Update Last States
            lastState = currentState;
            lastSnapPrimed = snapPrimed;


            if (currentState === STATE.COOLDOWN) {
                cooldownTimer -= 0.016; 
                if (cooldownTimer <= 0) {
                    currentState = STATE.IDLE;
                    uiSys.innerText = "SYSTEM: Ready";
                    uiSys.classList.remove('warning');
                    uiSys.style.color = "#0ff";
                }
                return;
            }

            if (currentState === STATE.EXPLODING) {
                cooldownTimer -= 0.016;
                if (cooldownTimer <= 0) {
                    currentState = STATE.COOLDOWN;
                    cooldownTimer = 2.0;
                    uiSys.innerText = "SYSTEM: Cooldown";
                }
                return;
            }

            // Check for Hands
            if (!handsData.left.present && !handsData.right.present) {
                currentState = STATE.IDLE;
                uiSys.innerText = "SYSTEM: Searching Hands...";
                return;
            }

            // Calculate Distance
            const dx = handsData.left.x - handsData.right.x;
            const dy = handsData.left.y - handsData.right.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            handsData.distance = dist;

            // Hand Interaction Logic
            if (handsData.left.present && handsData.right.present) {
                
                // 1. Maintain Holding State
                if (currentState === STATE.HOLDING) {
                     // Break condition: Hands moved too far apart
                     if (dist > CONFIG.breakDistance) {
                         currentState = STATE.SINGLE;
                         snapPrimed = false;
                         uiSys.innerText = "SYSTEM: Connection Lost";
                         uiSys.classList.remove('warning');
                         uiSys.style.color = "#0ff";
                         return;
                     }

                    // Snap Logic: Wait for Pinch then Release
                    const pinch = handsData.right.pinchDist;
                    
                    if (pinch < CONFIG.snapThreshold) {
                        snapPrimed = true;
                        uiSys.innerText = "SYSTEM: HOLLOW PURPLE - PRIMED...";
                        uiSys.style.color = "#d0f"; // Visual cue: Purple Text
                    } else if (snapPrimed && pinch > (CONFIG.snapThreshold + 0.05)) {
                        // Released!
                        triggerExplosion();
                        snapPrimed = false;
                        uiSys.style.color = "#0ff";
                    } else if (!snapPrimed) {
                         uiSys.innerText = "SYSTEM: HOLLOW PURPLE - READY (SNAP TO FIRE)";
                         uiSys.style.color = "#0ff";
                    }
                }
                // 2. Maintaining Merging State (waiting for timer)
                else if (currentState === STATE.MERGING) {
                    // Check if hands broke apart too early
                    if (dist > CONFIG.breakDistance) {
                        currentState = STATE.SINGLE;
                        uiSys.innerText = "SYSTEM: Forming Failed";
                        uiSys.classList.remove('warning');
                    }
                }
                // 3. Trigger Merge (From Single or Idle)
                else if (dist < CONFIG.mergeDistance) {
                    currentState = STATE.MERGING;
                    uiSys.innerText = "SYSTEM: HOLLOW PURPLE - FORMING";
                    uiSys.className = "stat-box warning";
                    uiSys.style.color = "#0ff";
                    
                    setTimeout(() => {
                        // Only transition if we haven't broken the state
                        if(currentState === STATE.MERGING) {
                            currentState = STATE.HOLDING;
                            uiSys.innerText = "SYSTEM: HOLLOW PURPLE - READY (SNAP TO FIRE)";
                            snapPrimed = false; 
                        }
                    }, 1000);
                }
                // 4. Default Single State
                else {
                    currentState = STATE.SINGLE;
                    uiSys.innerText = "SYSTEM: Techniques Active (Red/Blue)";
                    uiSys.classList.remove('warning');
                    uiSys.style.color = "#0ff";
                }

            } else {
                // If one hand lost, revert to single
                currentState = STATE.SINGLE; 
                uiSys.innerText = "SYSTEM: Single Technique";
                uiSys.classList.remove('warning');
                uiSys.style.color = "#0ff";
            }
        }

        function triggerExplosion() {
            currentState = STATE.EXPLODING;
            cooldownTimer = 1.0; 
            
            const flash = document.getElementById('flash-overlay');
            flash.style.opacity = 1;
            setTimeout(() => { flash.style.opacity = 0; }, 100);
            
            document.getElementById('log-system').innerText = "SYSTEM: KYOSHIKI MURASAKI (PURPLE)!";
        }

        // --- MEDIAPIPE HANDLER ---
        function onResults(results) {
            handsData.left.present = false;
            handsData.right.present = false;

            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const label = results.multiHandedness[i].label; 
                    
                    const palm = landmarks[PALM_IDX];
                    const thumbTip = landmarks[THUMB_TIP];
                    const middleTip = landmarks[MIDDLE_TIP];

                    const isFist = (
                        landmarks[8].y > landmarks[6].y && 
                        landmarks[12].y > landmarks[10].y && 
                        landmarks[16].y > landmarks[14].y 
                    );

                    const pinchDx = thumbTip.x - middleTip.x;
                    const pinchDy = thumbTip.y - middleTip.y;
                    const pinchDist = Math.sqrt(pinchDx*pinchDx + pinchDy*pinchDy);

                    const data = (label === 'Left') ? handsData.left : handsData.right;
                    
                    data.present = true;
                    data.x = 1.0 - palm.x; 
                    data.y = palm.y;
                    data.lastGesture = data.gesture; 
                    data.gesture = isFist ? 'FIST' : 'OPEN';
                    data.pinchDist = pinchDist;

                    const logId = (label === 'Left') ? 'log-left' : 'log-right';
                    const color = (label === 'Left') ? 'Red' : 'Blue';
                    document.getElementById(logId).innerText = 
                        `${label.toUpperCase()} (${color}): ${data.gesture} | Pinch: ${pinchDist.toFixed(2)}`;
                }
            }
        }

        // --- INITIALIZATION ---
        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloomStrength,
                CONFIG.bloomRadius,
                CONFIG.bloomThreshold
            );

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            particleSystem = new ParticleEngine(scene);

            const videoElement = document.getElementById('input_video');
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            camInstance = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            appTime += 0.02;

            updateLogic();
            particleSystem.update(0.016); 
            composer.render();
        }

        init();

    </script>
</body>
</html>