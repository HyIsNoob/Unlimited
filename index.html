<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gojo Satoru AR Experience</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        
        /* Video Background (Toggleable) */
        #input_video { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            z-index: 0; 
            transform: scaleX(-1); /* Mirror effect */
            display: none; /* Hidden by default */
        }
        
        /* Landing Page Overlay */
        #landing-page {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); /* Semi-transparent to see particles */
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s ease-out;
        }
        .landing-content {
            max-width: 900px;
            padding: 30px;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #333;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
            border-radius: 4px;
        }
        #landing-page h1 { color: #0ff; text-shadow: 0 0 15px #0ff; margin: 0 0 10px 0; font-size: 2.5rem; letter-spacing: 4px; }
        #landing-page .subtitle { color: #888; margin-bottom: 40px; font-size: 1rem; letter-spacing: 2px; text-transform: uppercase; }
        
        .tutorial-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 40px;
            text-align: left;
        }
        @media (max-width: 768px) {
            .tutorial-grid { grid-template-columns: 1fr; }
            #landing-page h1 { font-size: 1.8rem; }
        }
        .tutorial-card {
            border: 1px solid #333;
            padding: 20px;
            background: rgba(0,0,0,0.6);
            transition: transform 0.2s;
        }
        .tutorial-card:hover { border-color: #555; transform: translateY(-2px); }
        .tutorial-card h3 { color: #d0f; font-size: 1.1rem; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 10px; }
        .tutorial-card p { font-size: 0.9rem; color: #ccc; line-height: 1.5; margin: 0; }
        .key-highlight { color: #fff; font-weight: bold; }

        .info-note { margin-bottom: 30px; color: #0ff; font-size: 0.9rem; border-top: 1px solid #333; padding-top: 20px; width: 100%; }

        #start-btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 50px;
            font-size: 1.2rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: 0.3s;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            font-weight: bold;
        }
        #start-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
        }
        .credits-small { margin-top: 20px; font-size: 0.8rem; color: #444; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
            display: none; /* Hidden until start */
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .warning { color: #f00; text-shadow: 0 0 5px #f00; border-color: #f00; }
        
        /* Flash Effect Overlay */
        #flash-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 99;
            transition: opacity 0.1s ease-out;
        }

        /* Credits & Controls */
        #credit {
            position: absolute;
            top: 10px;
            right: 15px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 10px;
            z-index: 20;
            pointer-events: none;
            letter-spacing: 1px;
            display: none; /* Hidden until start */
        }

        #controls {
            position: absolute;
            top: 30px;
            right: 15px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            display: none; /* Hidden until start */
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #444;
            color: #888;
            padding: 6px 12px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            transition: all 0.3s;
            pointer-events: auto;
            text-transform: uppercase;
            width: 100px;
            text-align: center;
        }
        
        .control-btn.active {
            border-color: #0ff;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            background: rgba(0, 50, 50, 0.6);
        }

        .control-btn:hover {
            background: rgba(30, 30, 30, 0.8);
        }

        /* Canvas orientation normal (Mirror effect handled by logic) */
        canvas { display: block; }
    </style>

    <!-- 1. Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- 2. Post Processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- 3. MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Video Element for MediaPipe -->
    <video id="input_video"></video>

    <!-- Landing Page -->
    <div id="landing-page">
        <div class="landing-content">
            <h1>DOMAIN EXPANSION: AR</h1>
            <p class="subtitle">Gojo Satoru Cursed Technique Simulation</p>
            
            <div class="tutorial-grid">
                <div class="tutorial-card">
                    <h3>1. BLUE & RED</h3>
                    <p>Show your hands to activate techniques.<br>
                    <span class="key-highlight">Left Hand</span> = Reversal Red<br>
                    <span class="key-highlight">Right Hand</span> = Lapse Blue</p>
                </div>
                <div class="tutorial-card">
                    <h3>2. HOLLOW PURPLE</h3>
                    <p>Bring your <span class="key-highlight">palms close together</span> to merge the red and blue energies into the imaginary mass.</p>
                </div>
                <div class="tutorial-card">
                    <h3>3. SNAP TO FIRE</h3>
                    <p>While holding Purple, <span class="key-highlight">PINCH</span> (Thumb + Middle) and <span class="key-highlight">RELEASE</span> quickly to launch the attack.</p>
                </div>
            </div>

            <div class="info-note">
                <p>Toggle <strong>CAM: ON</strong> in the controls to see yourself as Gojo (Webcam Background).</p>
            </div>

            <button id="start-btn" onclick="startGame()">ENTER VOID</button>
            <div class="credits-small">Created by HyIsNoob</div>
        </div>
    </div>

    <!-- UI Logs -->
    <div id="ui-layer">
        <div class="stat-box" id="log-left">LEFT: Searching...</div>
        <div class="stat-box" id="log-right">RIGHT: Searching...</div>
        <div class="stat-box" id="log-system">SYSTEM: Idle</div>
    </div>

    <!-- Credits & Controls -->
    <div id="credit">HyIsNoob</div>
    <div id="controls">
        <button id="btn-cam" class="control-btn" onclick="toggleCamera()">Cam: OFF</button>
        <button id="btn-log" class="control-btn active" onclick="toggleLogs()">Logs: ON</button>
    </div>

    <!-- Screen Flash -->
    <div id="flash-overlay"></div>

    <!-- Main Logic -->
    <script>
        // --- CONSTANTS ---
        const PALM_IDX = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_TIP = 12;
        const RING_TIP = 16;
        const PINKY_TIP = 20;

        const STATE = {
            IDLE: 'IDLE',
            SINGLE: 'SINGLE', // Red/Blue separate
            MERGING: 'MERGING', // Hands close, forming purple
            HOLDING: 'HOLDING', // Purple formed, waiting for snap
            EXPLODING: 'EXPLODING', // Boom
            COOLDOWN: 'COOLDOWN'
        };

        // Configuration
        const CONFIG = {
            particleCount: 6000, 
            mergeDistance: 0.20,
            breakDistance: 0.40,
            hollowRadius: 0.2, 
            snapThreshold: 0.08, 
            bloomStrength: 3.0, 
            bloomRadius: 0.6,
            bloomThreshold: 0,
        };

        // Global Variables
        let camera, scene, renderer, composer;
        let particleSystem;
        let currentState = STATE.IDLE;
        let snapPrimed = false; 
        let appTime = 0;
        let cooldownTimer = 0;
        let gameStarted = false; // Flag to check if start button pressed
        let camInstance = null; // Camera instance
        
        // Hand Data Container
        const handsData = {
            left: { present: false, x: 0, y: 0, gesture: 'OPEN', pinchDist: 1 },
            right: { present: false, x: 0, y: 0, gesture: 'OPEN', pinchDist: 1 },
            distance: 1, 
            center: new THREE.Vector3() 
        };

        // --- UTILS: TEXTURE GENERATION ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- CONTROLS LOGIC ---
        function toggleCamera() {
            const video = document.getElementById('input_video');
            const btn = document.getElementById('btn-cam');
            if (video.style.display === 'block') {
                video.style.display = 'none';
                btn.innerText = 'CAM: OFF';
                btn.classList.remove('active');
            } else {
                video.style.display = 'block';
                btn.innerText = 'CAM: ON';
                btn.classList.add('active');
            }
        }

        function toggleLogs() {
            const ui = document.getElementById('ui-layer');
            const btn = document.getElementById('btn-log');
            if (ui.style.display === 'none') {
                ui.style.display = 'block';
                btn.innerText = 'LOGS: ON';
                btn.classList.add('active');
            } else {
                ui.style.display = 'none';
                btn.innerText = 'LOGS: OFF';
                btn.classList.remove('active');
            }
        }

        // --- START GAME LOGIC ---
        function startGame() {
            const landing = document.getElementById('landing-page');
            landing.style.opacity = '0';
            setTimeout(() => { landing.style.display = 'none'; }, 500);

            // Show UI elements
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('credit').style.display = 'block';
            document.getElementById('controls').style.display = 'flex';

            gameStarted = true;
            if (camInstance) {
                camInstance.start();
            }
        }

        // --- PARTICLE SYSTEM ENGINE ---
        class ParticleEngine {
            constructor(scene) {
                this.count = CONFIG.particleCount;
                this.geometry = new THREE.BufferGeometry();
                
                // Attributes
                const positions = new Float32Array(this.count * 3);
                const colors = new Float32Array(this.count * 3);
                const sizes = new Float32Array(this.count);
                
                // Custom data for physics
                this.velocities = new Float32Array(this.count * 3);
                this.angles = new Float32Array(this.count); // For spiraling
                this.radii = new Float32Array(this.count); // Distance from center

                for (let i = 0; i < this.count; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 10;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 5;
                    
                    colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                    sizes[i] = 0.5;
                    this.angles[i] = Math.random() * Math.PI * 2;
                    // Init radii spread out
                    this.radii[i] = 0.5 + Math.random() * 3.0; 
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.PointsMaterial({
                    size: 0.2,
                    map: createGlowTexture(),
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    opacity: 0.8
                });

                this.mesh = new THREE.Points(this.geometry, material);
                this.mesh.frustumCulled = false; // Always render
                scene.add(this.mesh);
            }

            update(dt) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.color.array;
                const sizes = this.geometry.attributes.size.array;
                
                // Color Definitions
                const colRed = { r: 1, g: 0.1, b: 0.1 };
                const colBlue = { r: 0.1, g: 0.3, b: 1 };
                // Enhanced Purple colors
                const colPurpleAura = { r: 0.6, g: 0.0, b: 1.0 }; // Deep Violet

                // Pre-calc targets mapped to 3D space
                const mapTo3D = (x, y) => {
                    return {
                        x: (x - 0.5) * 8, // Scale to screen width
                        y: -(y - 0.5) * 6, // Scale to screen height, invert Y
                        z: 0
                    };
                };

                const leftPos = mapTo3D(handsData.left.x, handsData.left.y);
                const rightPos = mapTo3D(handsData.right.x, handsData.right.y);
                const centerPos = mapTo3D(
                    (handsData.left.x + handsData.right.x) / 2, 
                    (handsData.left.y + handsData.right.y) / 2
                );

                for (let i = 0; i < this.count; i++) {
                    const idx = i * 3;
                    let pX = positions[idx];
                    let pY = positions[idx+1];
                    let pZ = positions[idx+2];
                    
                    // Logic Switch based on State
                    if (currentState === STATE.EXPLODING) {
                        // Explosion logic
                        pX += this.velocities[idx] * dt * 50;
                        pY += this.velocities[idx+1] * dt * 50;
                        pZ += this.velocities[idx+2] * dt * 50;
                        sizes[i] *= 0.92;

                    } else if (currentState === STATE.HOLDING || currentState === STATE.MERGING) {
                        // --- HOLLOW PURPLE LOGIC ---
                        const target = centerPos;
                        const type = i % 10;
                        const isCore = type < 3; 
                        
                        if (isCore) {
                            if (type === 0) {
                                // Singularity
                                const theta = appTime * 20 + i;
                                const phi = i * 0.5;
                                const r = 0.2 * Math.random(); 
                                const tx = target.x + Math.sin(theta) * Math.cos(phi) * r;
                                const ty = target.y + Math.sin(theta) * Math.sin(phi) * r;
                                const tz = target.z + Math.cos(theta) * r;
                                pX += (tx - pX) * 0.5; pY += (ty - pY) * 0.5; pZ += (tz - pZ) * 0.5;
                                const flicker = Math.sin(appTime * 40 + i);
                                if (flicker > 0) { colors[idx] = 1.0; colors[idx+1] = 1.0; colors[idx+2] = 1.0; } 
                                else { colors[idx] = 0.2; colors[idx+1] = 1.0; colors[idx+2] = 1.0; }
                                sizes[i] = 0.4 + Math.random() * 0.4;
                            } else {
                                // Atomic Orbits
                                const speed = 4.0; const scale = 1.2;
                                const angle = this.angles[i] + dt * speed;
                                this.angles[i] = angle;
                                const u = angle; const v = angle * (1.5 + (i%3)*0.5);
                                const tx = target.x + Math.sin(u) * Math.cos(v) * scale;
                                const ty = target.y + Math.cos(u) * Math.cos(v) * scale;
                                const tz = target.z + Math.sin(v) * scale;
                                pX += (tx - pX) * 0.2; pY += (ty - pY) * 0.2; pZ += (tz - pZ) * 0.2;
                                colors[idx] = 1.0; colors[idx+1] = 0.0; colors[idx+2] = 0.8; 
                                sizes[i] = 0.2 + Math.random() * 0.2;
                            }
                        } else {
                            // Aura
                            this.angles[i] += dt * 3.0;
                            const baseScale = 3.5;
                            const noise = Math.sin(i * 0.5 + appTime * 8.0);
                            const spike = (Math.random() > 0.97) ? 2.5 : 1.0; 
                            const r = baseScale * spike + noise * 0.4;
                            const tx = target.x + Math.cos(this.angles[i] + i) * r;
                            const ty = target.y + Math.sin(this.angles[i] + i) * r;
                            const tz = target.z + Math.cos(i * 13.0) * r; 
                            const jitter = 0.15;
                            pX += (tx - pX) * 0.1 + (Math.random()-0.5) * jitter;
                            pY += (ty - pY) * 0.1 + (Math.random()-0.5) * jitter;
                            pZ += (tz - pZ) * 0.1 + (Math.random()-0.5) * jitter;
                            const isVoid = Math.random() > 0.95;
                            if (isVoid) { colors[idx] = 0.1; colors[idx+1] = 0.0; colors[idx+2] = 0.2; } 
                            else { colors[idx] = colPurpleAura.r; colors[idx+1] = colPurpleAura.g; colors[idx+2] = colPurpleAura.b; }
                            sizes[i] = 0.2 + Math.random() * 0.4;
                        }

                        // Prep explosion velocities
                        const dirX = pX - target.x; const dirY = pY - target.y; const dirZ = pZ - target.z;
                        const len = Math.sqrt(dirX*dirX + dirY*dirY + dirZ*dirZ) + 0.001;
                        this.velocities[idx] = (dirX / len) + (Math.random()-0.5)*0.5;
                        this.velocities[idx+1] = (dirY / len) + (Math.random()-0.5)*0.5;
                        this.velocities[idx+2] = (dirZ / len) + (Math.random()-0.5)*0.5;

                    } else if (currentState === STATE.SINGLE) {
                        // Red / Blue Logic
                        const isLeft = i % 2 === 0;
                        const hand = isLeft ? handsData.left : handsData.right;
                        const target = isLeft ? leftPos : rightPos;
                        const col = isLeft ? colRed : colBlue;
                        
                        if (hand.present) {
                            if (hand.gesture === 'FIST') {
                                // Vortex
                                const r = this.radii[i];
                                const spinDir = isLeft ? -1 : 1;
                                const w = spinDir * (5.0 + 12.0 / (r * r + 0.1)); 
                                this.angles[i] += dt * w;
                                const suctionSpeed = 3.5 + (4.0 / (r + 0.1));
                                this.radii[i] -= dt * suctionSpeed;
                                if (this.radii[i] < 0.1) {
                                    this.radii[i] = 4.0 + Math.random() * 6.0; 
                                    this.angles[i] = Math.random() * Math.PI * 2; 
                                }
                                const currR = this.radii[i];
                                const zNoise = Math.sin(i * 12.34) * (currR * 0.4);
                                const tx = target.x + Math.cos(this.angles[i]) * currR;
                                const ty = target.y + Math.sin(this.angles[i]) * currR;
                                const tz = target.z + zNoise;
                                const lerpT = 0.3 + (1.0 / (currR + 1.0)) * 0.5;
                                pX += (tx - pX) * lerpT; pY += (ty - pY) * lerpT; pZ += (tz - pZ) * lerpT;
                                const intensity = 1.0 / (currR * 0.8 + 0.1);
                                sizes[i] = 0.15 + intensity * 0.25;
                                const coreMix = Math.min(1.0, 0.4 / (currR + 0.1));
                                colors[idx] = col.r + (1 - col.r) * coreMix;
                                colors[idx+1] = col.g + (1 - col.g) * coreMix;
                                colors[idx+2] = col.b + (1 - col.b) * coreMix;

                            } else {
                                // Shell
                                const rotationSpeed = isLeft ? -1.5 : 1.5; 
                                this.angles[i] += dt * rotationSpeed;
                                const stableRandom = (i % 100) / 100.0;
                                const targetRadius = 1.2 + stableRandom * 1.5;
                                const diff = targetRadius - this.radii[i];
                                this.radii[i] += diff * dt * 2.0; 
                                const r = this.radii[i];
                                const verticalSway = Math.sin(appTime * 1.5 + i * 0.1) * 0.3;
                                const zPhase = (i % 20) * 0.3;
                                const tx = target.x + Math.cos(this.angles[i]) * r;
                                const ty = target.y + Math.sin(this.angles[i]) * r + verticalSway;
                                const tz = target.z + Math.sin(this.angles[i] + zPhase) * (r * 0.6); 
                                pX += (tx - pX) * 0.1; pY += (ty - pY) * 0.1; pZ += (tz - pZ) * 0.1;
                                sizes[i] = 0.2 + Math.sin(appTime * 2.0 + i) * 0.1;
                                colors[idx] = col.r; colors[idx+1] = col.g; colors[idx+2] = col.b;
                            }
                        } else {
                             // Scatter
                            colors[idx] *= 0.9; colors[idx+1] *= 0.9; colors[idx+2] *= 0.9;
                        }

                    } else {
                        // IDLE / BACKGROUND MODE
                        // Particles drift gently for the landing page background
                        pY += dt * 0.5;
                        if (pY > 5) {
                            pY = -5;
                            pX = (Math.random() - 0.5) * 10;
                            pZ = (Math.random() - 0.5) * 5;
                            // Reset brightness for loop
                            colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1;
                        }
                        // Gentle fade but keep them visible
                        colors[idx] = Math.max(0.2, colors[idx] * 0.99); 
                        colors[idx+1] = Math.max(0.2, colors[idx+1] * 0.99); 
                        colors[idx+2] = Math.max(0.2, colors[idx+2] * 0.99);
                    }

                    positions[idx] = pX;
                    positions[idx+1] = pY;
                    positions[idx+2] = pZ;
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
        }

        // --- GAME LOGIC ---
        function updateLogic() {
            if (!gameStarted) return; // Only process hand logic if game started

            const uiSys = document.getElementById('log-system');

            if (currentState === STATE.COOLDOWN) {
                cooldownTimer -= 0.016; 
                if (cooldownTimer <= 0) {
                    currentState = STATE.IDLE;
                    uiSys.innerText = "SYSTEM: Ready";
                    uiSys.classList.remove('warning');
                    uiSys.style.color = "#0ff";
                }
                return;
            }

            if (currentState === STATE.EXPLODING) {
                cooldownTimer -= 0.016;
                if (cooldownTimer <= 0) {
                    currentState = STATE.COOLDOWN;
                    cooldownTimer = 2.0;
                    uiSys.innerText = "SYSTEM: Cooldown";
                }
                return;
            }

            // Check for Hands
            if (!handsData.left.present && !handsData.right.present) {
                currentState = STATE.IDLE;
                uiSys.innerText = "SYSTEM: Searching Hands...";
                return;
            }

            // Calculate Distance
            const dx = handsData.left.x - handsData.right.x;
            const dy = handsData.left.y - handsData.right.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            handsData.distance = dist;

            // Hand Interaction Logic
            if (handsData.left.present && handsData.right.present) {
                
                // 1. Maintain Holding State
                if (currentState === STATE.HOLDING) {
                     // Break condition: Hands moved too far apart
                     if (dist > CONFIG.breakDistance) {
                         currentState = STATE.SINGLE;
                         snapPrimed = false;
                         uiSys.innerText = "SYSTEM: Connection Lost";
                         uiSys.classList.remove('warning');
                         uiSys.style.color = "#0ff";
                         return;
                     }

                    // Snap Logic: Wait for Pinch then Release
                    const pinch = handsData.right.pinchDist;
                    
                    if (pinch < CONFIG.snapThreshold) {
                        snapPrimed = true;
                        uiSys.innerText = "SYSTEM: HOLLOW PURPLE - PRIMED...";
                        uiSys.style.color = "#d0f"; // Visual cue: Purple Text
                    } else if (snapPrimed && pinch > (CONFIG.snapThreshold + 0.05)) {
                        // Released!
                        triggerExplosion();
                        snapPrimed = false;
                        uiSys.style.color = "#0ff";
                    } else if (!snapPrimed) {
                         uiSys.innerText = "SYSTEM: HOLLOW PURPLE - READY (SNAP TO FIRE)";
                         uiSys.style.color = "#0ff";
                    }
                }
                // 2. Maintaining Merging State (waiting for timer)
                else if (currentState === STATE.MERGING) {
                    // Check if hands broke apart too early
                    if (dist > CONFIG.breakDistance) {
                        currentState = STATE.SINGLE;
                        uiSys.innerText = "SYSTEM: Forming Failed";
                        uiSys.classList.remove('warning');
                    }
                }
                // 3. Trigger Merge (From Single or Idle)
                else if (dist < CONFIG.mergeDistance) {
                    currentState = STATE.MERGING;
                    uiSys.innerText = "SYSTEM: HOLLOW PURPLE - FORMING";
                    uiSys.className = "stat-box warning";
                    uiSys.style.color = "#0ff";
                    
                    setTimeout(() => {
                        // Only transition if we haven't broken the state
                        if(currentState === STATE.MERGING) {
                            currentState = STATE.HOLDING;
                            uiSys.innerText = "SYSTEM: HOLLOW PURPLE - READY (SNAP TO FIRE)";
                            snapPrimed = false; 
                        }
                    }, 1000);
                }
                // 4. Default Single State
                else {
                    currentState = STATE.SINGLE;
                    uiSys.innerText = "SYSTEM: Techniques Active (Red/Blue)";
                    uiSys.classList.remove('warning');
                    uiSys.style.color = "#0ff";
                }

            } else {
                // If one hand lost, revert to single
                currentState = STATE.SINGLE; 
                uiSys.innerText = "SYSTEM: Single Technique";
                uiSys.classList.remove('warning');
                uiSys.style.color = "#0ff";
            }
        }

        function triggerExplosion() {
            currentState = STATE.EXPLODING;
            cooldownTimer = 1.0; 
            
            const flash = document.getElementById('flash-overlay');
            flash.style.opacity = 1;
            setTimeout(() => { flash.style.opacity = 0; }, 100);
            
            document.getElementById('log-system').innerText = "SYSTEM: KYOSHIKI MURASAKI (PURPLE)!";
        }

        // --- MEDIAPIPE HANDLER ---
        function onResults(results) {
            handsData.left.present = false;
            handsData.right.present = false;

            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const label = results.multiHandedness[i].label; 
                    
                    const palm = landmarks[PALM_IDX];
                    const thumbTip = landmarks[THUMB_TIP];
                    const middleTip = landmarks[MIDDLE_TIP];

                    const isFist = (
                        landmarks[8].y > landmarks[6].y && 
                        landmarks[12].y > landmarks[10].y && 
                        landmarks[16].y > landmarks[14].y 
                    );

                    const pinchDx = thumbTip.x - middleTip.x;
                    const pinchDy = thumbTip.y - middleTip.y;
                    const pinchDist = Math.sqrt(pinchDx*pinchDx + pinchDy*pinchDy);

                    const data = (label === 'Left') ? handsData.left : handsData.right;
                    
                    data.present = true;
                    data.x = 1.0 - palm.x; 
                    data.y = palm.y;
                    data.gesture = isFist ? 'FIST' : 'OPEN';
                    data.pinchDist = pinchDist;

                    const logId = (label === 'Left') ? 'log-left' : 'log-right';
                    const color = (label === 'Left') ? 'Red' : 'Blue';
                    document.getElementById(logId).innerText = 
                        `${label.toUpperCase()} (${color}): ${data.gesture} | Pinch: ${pinchDist.toFixed(2)}`;
                }
            }
        }

        // --- INITIALIZATION ---
        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloomStrength,
                CONFIG.bloomRadius,
                CONFIG.bloomThreshold
            );

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            particleSystem = new ParticleEngine(scene);

            const videoElement = document.getElementById('input_video');
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            // Store camera instance globally but don't start yet
            camInstance = new window.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            // camInstance.start(); // Moved to startGame()

            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            appTime += 0.02;

            updateLogic();
            particleSystem.update(0.016); 
            composer.render();
        }

        init();

    </script>
</body>
</html>